// Code generated by 'ccgo sys/vfs/gen.c -crt-import-path "" -export-defines "" -export-enums "" -export-externs X -export-fields F -export-structs "" -export-typedefs "" -header -hide _OSSwapInt16,_OSSwapInt32,_OSSwapInt64 -ignore-unsupported-alignment -o sys/vfs/vfs_illumos_amd64.go -pkgname vfs', DO NOT EDIT.

package vfs

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer

const (
	ADMIN_HIGH                           = "ADMIN_HIGH"                      // label.h:48:1:
	ADMIN_LOW                            = "ADMIN_LOW"                       // label.h:47:1:
	AD_BOOT                              = 1                                 // uadmin.h:58:1:
	AD_CHECK                             = 2                                 // uadmin.h:81:1:
	AD_CHECK_SUSPEND_TO_DISK             = 2                                 // uadmin.h:83:1:
	AD_CHECK_SUSPEND_TO_RAM              = 21                                // uadmin.h:85:1:
	AD_COMPRESS                          = 0                                 // uadmin.h:79:1:
	AD_FASTREBOOT                        = 8                                 // uadmin.h:64:1:
	AD_FASTREBOOT_DRYRUN                 = 9                                 // uadmin.h:65:1:
	AD_FORCE                             = 1                                 // uadmin.h:80:1:
	AD_FTRACE_START                      = 1                                 // uadmin.h:95:1:
	AD_FTRACE_STOP                       = 2                                 // uadmin.h:96:1:
	AD_HALT                              = 0                                 // uadmin.h:57:1:
	AD_IBOOT                             = 2                                 // uadmin.h:59:1:
	AD_NOSYNC                            = 7                                 // uadmin.h:63:1:
	AD_POWEROFF                          = 6                                 // uadmin.h:62:1:
	AD_REUSABLE                          = 4                                 // uadmin.h:92:1:
	AD_REUSEFINI                         = 5                                 // uadmin.h:93:1:
	AD_REUSEINIT                         = 3                                 // uadmin.h:91:1:
	AD_SBOOT                             = 3                                 // uadmin.h:60:1:
	AD_SIBOOT                            = 4                                 // uadmin.h:61:1:
	AD_SUSPEND_TO_DISK                   = 0                                 // uadmin.h:82:1:
	AD_SUSPEND_TO_RAM                    = 20                                // uadmin.h:84:1:
	AD_UNKNOWN                           = -1                                // uadmin.h:56:1:
	AD_UPDATE_BOOT_CONFIG                = 1                                 // uadmin.h:101:1:
	ALL_ZONES                            = -1                                // zone.h:94:1:
	ATTR_COMM                            = 0x04                              // vnode.h:1545:1:
	ATTR_EXEC                            = 0x02                              // vnode.h:1544:1:
	ATTR_HINT                            = 0x08                              // vnode.h:1546:1:
	ATTR_NOACLCHECK                      = 0x20                              // vnode.h:1548:1:
	ATTR_REAL                            = 0x10                              // vnode.h:1547:1:
	ATTR_TRIGGER                         = 0x40                              // vnode.h:1549:1:
	ATTR_UTIME                           = 0x01                              // vnode.h:1543:1:
	AT_ALL                               = 49151                             // vnode.h:619:1:
	AT_ATIME                             = 0x00100                           // vnode.h:603:1:
	AT_BLKSIZE                           = 0x01000                           // vnode.h:607:1:
	AT_CTIME                             = 0x00400                           // vnode.h:605:1:
	AT_FSID                              = 0x00010                           // vnode.h:599:1:
	AT_GID                               = 0x00008                           // vnode.h:598:1:
	AT_MODE                              = 0x00002                           // vnode.h:596:1:
	AT_MTIME                             = 0x00200                           // vnode.h:604:1:
	AT_NBLOCKS                           = 0x02000                           // vnode.h:608:1:
	AT_NLINK                             = 0x00040                           // vnode.h:601:1:
	AT_NODEID                            = 0x00020                           // vnode.h:600:1:
	AT_NOSET                             = 47217                             // vnode.h:628:1:
	AT_RDEV                              = 0x00800                           // vnode.h:606:1:
	AT_SEQ                               = 0x08000                           // vnode.h:610:1:
	AT_SIZE                              = 0x00080                           // vnode.h:602:1:
	AT_STAT                              = 4095                              // vnode.h:623:1:
	AT_TIMES                             = 1792                              // vnode.h:626:1:
	AT_TYPE                              = 0x00001                           // vnode.h:595:1:
	AT_UID                               = 0x00004                           // vnode.h:597:1:
	AT_XVATTR                            = 0x10000                           // vnode.h:617:1:
	AVL_AFTER                            = 1                                 // avl.h:132:1:
	AVL_BEFORE                           = 0                                 // avl.h:131:1:
	AV_SCANSTAMP_SZ                      = 32                                // vnode.h:453:1:
	A_CONFIG                             = 23                                // uadmin.h:54:1:
	A_DUMP                               = 5                                 // uadmin.h:49:1:
	A_FREEZE                             = 3                                 // uadmin.h:47:1:
	A_FTRACE                             = 15                                // uadmin.h:50:1:
	A_REBOOT                             = 1                                 // uadmin.h:45:1:
	A_REMOUNT                            = 4                                 // uadmin.h:48:1:
	A_SDTTEST                            = 22                                // uadmin.h:53:1:
	A_SHUTDOWN                           = 2                                 // uadmin.h:46:1:
	A_SWAPCTL                            = 16                                // uadmin.h:51:1:
	BOOTARGS_MAX                         = 256                               // uadmin.h:108:1:
	BOOT_CONFIG_PG_FBBLACKLIST           = "fastreboot_blacklist"            // uadmin.h:125:1:
	BOOT_CONFIG_PG_OVR                   = "config_ovr"                      // uadmin.h:131:1:
	BOOT_CONFIG_PG_PARAMS                = "config"                          // uadmin.h:120:1:
	CANBSIZ                              = 256                               // param.h:91:1:
	CC_DONTBLOCK                         = 0x02                              // vnode.h:886:1:
	CC_WOULDBLOCK                        = 0x01                              // vnode.h:885:1:
	CDLIMIT                              = 2048                              // param.h:164:1:
	CLOCKS_PER_SEC                       = 1000000                           // time_iso.h:78:1:
	CLOCK_HIGHRES                        = 4                                 // time_impl.h:126:1:
	CLOCK_LEVEL                          = 10                                // machlock.h:109:1:
	CLOCK_MONOTONIC                      = 4                                 // time_impl.h:124:1:
	CLOCK_PROCESS_CPUTIME_ID             = 5                                 // time_impl.h:125:1:
	CLOCK_PROF                           = 2                                 // time_impl.h:127:1:
	CLOCK_REALTIME                       = 3                                 // time_impl.h:123:1:
	CLOCK_THREAD_CPUTIME_ID              = 2                                 // time_impl.h:122:1:
	CLOCK_VIRTUAL                        = 1                                 // time_impl.h:121:1:
	CMASK                                = 022                               // param.h:163:1:
	CPU_INTR_ACTV_HIGH_LEVEL_MASK        = 0xF800                            // machlock.h:120:1:
	CREATE_XATTR_DIR                     = 0x04                              // vnode.h:1267:1:
	DEFAULT_JUMPPID                      = 0                                 // param.h:120:1:
	DEFAULT_MAXPID                       = 30000                             // param.h:119:1:
	DEV_BSHIFT                           = 9                                 // param.h:251:1:
	DEV_BSIZE                            = 512                               // param.h:250:1:
	DISP_LEVEL                           = 11                                // machlock.h:111:1:
	DOMINANCE_CHECK                      = 1                                 // label.h:44:1:
	DST_AUST                             = 2                                 // time.h:115:1:
	DST_AUSTALT                          = 10                                // time.h:123:1:
	DST_CAN                              = 6                                 // time.h:119:1:
	DST_EET                              = 5                                 // time.h:118:1:
	DST_GB                               = 7                                 // time.h:120:1:
	DST_MET                              = 4                                 // time.h:117:1:
	DST_NONE                             = 0                                 // time.h:113:1:
	DST_RUM                              = 8                                 // time.h:121:1:
	DST_TUR                              = 9                                 // time.h:122:1:
	DST_USA                              = 1                                 // time.h:114:1:
	DST_WET                              = 3                                 // time.h:116:1:
	DUMP_ALLOC                           = 0                                 // vnode.h:1286:1:
	DUMP_FREE                            = 1                                 // vnode.h:1287:1:
	DUMP_SCAN                            = 2                                 // vnode.h:1288:1:
	EQUALITY_CHECK                       = 0                                 // label.h:43:1:
	FASTREBOOT_DEFAULT                   = "fastreboot_default"              // uadmin.h:141:1:
	FASTREBOOT_ONPANIC                   = "fastreboot_onpanic"              // uadmin.h:142:1:
	FASTREBOOT_ONPANIC_CMDLINE           = "fastreboot_onpanic_cmdline"      // uadmin.h:143:1:
	FD_SETSIZE                           = 65536                             // select.h:88:1:
	FMRI_BOOT_CONFIG                     = "svc:/system/boot-config:default" // uadmin.h:114:1:
	FSCALE                               = 256                               // param.h:304:1:
	FSHIFT                               = 8                                 // param.h:303:1:
	FSTYPSZ                              = 16                                // statvfs.h:49:1:
	GID_NETADM                           = 65                                // param.h:100:1:
	GID_NOBODY                           = 60001                             // param.h:95:1:
	GID_UNKNOWN                          = 96                                // param.h:97:1:
	GLOBAL_ZONEID                        = 0                                 // zone.h:88:1:
	GLOBAL_ZONENAME                      = "global"                          // zone.h:313:1:
	HIGH_LEVELS                          = 5                                 // machlock.h:113:1:
	IMPLINK_HIGHEXPER                    = 158                               // in.h:284:1:
	IMPLINK_IP                           = 155                               // in.h:282:1:
	IMPLINK_LOWEXPER                     = 156                               // in.h:283:1:
	INADDR_6TO4RRANYCAST                 = 0xc0586301                        // in.h:392:1:
	INADDR_ALLHOSTS_GROUP                = 0xe0000001                        // in.h:372:1:
	INADDR_ALLRPTS_GROUP                 = 0xe0000016                        // in.h:374:1:
	INADDR_ALLRTRS_GROUP                 = 0xe0000002                        // in.h:373:1:
	INADDR_ANY                           = 0x00000000                        // in.h:366:1:
	INADDR_BROADCAST                     = 0xffffffff                        // in.h:368:1:
	INADDR_LOOPBACK                      = 0x7F000001                        // in.h:367:1:
	INADDR_MAX_LOCAL_GROUP               = 0xe00000ff                        // in.h:375:1:
	INADDR_NONE                          = 0xffffffff                        // in.h:369:1:
	INADDR_UNSPEC_GROUP                  = 0xe0000000                        // in.h:371:1:
	INET6_ADDRSTRLEN                     = 46                                // in.h:1212:1:
	INET_ADDRSTRLEN                      = 16                                // in.h:1210:1:
	IN_AUTOCONF_MASK                     = 0xffff0000                        // in.h:379:1:
	IN_AUTOCONF_NET                      = 0xa9fe0000                        // in.h:378:1:
	IN_CLASSA_HOST                       = 0x00ffffff                        // in.h:332:1:
	IN_CLASSA_MAX                        = 128                               // in.h:333:1:
	IN_CLASSA_NET                        = 0xff000000                        // in.h:330:1:
	IN_CLASSA_NSHIFT                     = 24                                // in.h:331:1:
	IN_CLASSB_HOST                       = 0x0000ffff                        // in.h:338:1:
	IN_CLASSB_MAX                        = 65536                             // in.h:339:1:
	IN_CLASSB_NET                        = 0xffff0000                        // in.h:336:1:
	IN_CLASSB_NSHIFT                     = 16                                // in.h:337:1:
	IN_CLASSC_HOST                       = 0x000000ff                        // in.h:344:1:
	IN_CLASSC_NET                        = 0xffffff00                        // in.h:342:1:
	IN_CLASSC_NSHIFT                     = 8                                 // in.h:343:1:
	IN_CLASSD_HOST                       = 0x0fffffff                        // in.h:349:1:
	IN_CLASSD_NET                        = 0xf0000000                        // in.h:347:1:
	IN_CLASSD_NSHIFT                     = 28                                // in.h:348:1:
	IN_CLASSE_NET                        = 0xffffffff                        // in.h:352:1:
	IN_LOOPBACKNET                       = 127                               // in.h:395:1:
	IN_PRIVATE12_MASK                    = 0xfff00000                        // in.h:383:1:
	IN_PRIVATE12_NET                     = 0xac100000                        // in.h:382:1:
	IN_PRIVATE16_MASK                    = 0xffff0000                        // in.h:385:1:
	IN_PRIVATE16_NET                     = 0xc0a80000                        // in.h:384:1:
	IN_PRIVATE8_MASK                     = 0xff000000                        // in.h:381:1:
	IN_PRIVATE8_NET                      = 0x0a000000                        // in.h:380:1:
	IPPORT_BIFFUDP                       = 512                               // in.h:250:1:
	IPPORT_BOOTPC                        = 68                                // in.h:214:1:
	IPPORT_BOOTPS                        = 67                                // in.h:213:1:
	IPPORT_CHARGEN                       = 19                                // in.h:199:1:
	IPPORT_CMDSERVER                     = 514                               // in.h:243:1:
	IPPORT_DAYTIME                       = 13                                // in.h:197:1:
	IPPORT_DHCPV6C                       = 546                               // in.h:260:1:
	IPPORT_DHCPV6S                       = 547                               // in.h:261:1:
	IPPORT_DISCARD                       = 9                                 // in.h:195:1:
	IPPORT_DOMAIN                        = 53                                // in.h:206:1:
	IPPORT_ECHO                          = 7                                 // in.h:194:1:
	IPPORT_EFSSERVER                     = 520                               // in.h:245:1:
	IPPORT_EXECSERVER                    = 512                               // in.h:241:1:
	IPPORT_FINGER                        = 79                                // in.h:217:1:
	IPPORT_FTP                           = 21                                // in.h:200:1:
	IPPORT_HTTP                          = 80                                // in.h:218:1:
	IPPORT_HTTP_ALT                      = 8080                              // in.h:219:1:
	IPPORT_IKE                           = 500                               // in.h:235:1:
	IPPORT_IKE_NATT                      = 4500                              // in.h:236:1:
	IPPORT_LDAP                          = 389                               // in.h:226:1:
	IPPORT_LOGINSERVER                   = 513                               // in.h:242:1:
	IPPORT_MDNS                          = 5353                              // in.h:207:1:
	IPPORT_MIP                           = 434                               // in.h:228:1:
	IPPORT_MTP                           = 57                                // in.h:208:1:
	IPPORT_NAMESERVER                    = 42                                // in.h:204:1:
	IPPORT_NETBIOS_DGM                   = 138                               // in.h:224:1:
	IPPORT_NETBIOS_NS                    = 137                               // in.h:223:1:
	IPPORT_NETBIOS_SSN                   = 139                               // in.h:225:1:
	IPPORT_NETSTAT                       = 15                                // in.h:198:1:
	IPPORT_NTP                           = 123                               // in.h:222:1:
	IPPORT_PRINTER                       = 515                               // in.h:244:1:
	IPPORT_RESERVED                      = 1024                              // in.h:271:1:
	IPPORT_RIPNG                         = 521                               // in.h:255:1:
	IPPORT_RJE                           = 77                                // in.h:216:1:
	IPPORT_ROUTESERVER                   = 520                               // in.h:254:1:
	IPPORT_SLP                           = 427                               // in.h:227:1:
	IPPORT_SMB                           = 445                               // in.h:229:1:
	IPPORT_SMTP                          = 25                                // in.h:202:1:
	IPPORT_SOCKS                         = 1080                              // in.h:263:1:
	IPPORT_SUPDUP                        = 95                                // in.h:221:1:
	IPPORT_SYSLOG                        = 514                               // in.h:252:1:
	IPPORT_SYSTAT                        = 11                                // in.h:196:1:
	IPPORT_TALK                          = 517                               // in.h:253:1:
	IPPORT_TELNET                        = 23                                // in.h:201:1:
	IPPORT_TFTP                          = 69                                // in.h:215:1:
	IPPORT_TIMESERVER                    = 37                                // in.h:203:1:
	IPPORT_TTYLINK                       = 87                                // in.h:220:1:
	IPPORT_USERRESERVED                  = 5000                              // in.h:272:1:
	IPPORT_VXLAN                         = 4789                              // in.h:230:1:
	IPPORT_WHOIS                         = 43                                // in.h:205:1:
	IPPORT_WHOSERVER                     = 513                               // in.h:251:1:
	IPPROTO_AH                           = 51                                // in.h:169:1:
	IPPROTO_DSTOPTS                      = 60                                // in.h:172:1:
	IPPROTO_EGP                          = 8                                 // in.h:160:1:
	IPPROTO_ENCAP                        = 4                                 // in.h:158:1:
	IPPROTO_EON                          = 80                                // in.h:175:1:
	IPPROTO_ESP                          = 50                                // in.h:168:1:
	IPPROTO_FRAGMENT                     = 44                                // in.h:166:1:
	IPPROTO_GGP                          = 3                                 // in.h:157:1:
	IPPROTO_HELLO                        = 63                                // in.h:173:1:
	IPPROTO_HOPOPTS                      = 0                                 // in.h:154:1:
	IPPROTO_ICMP                         = 1                                 // in.h:155:1:
	IPPROTO_ICMPV6                       = 58                                // in.h:170:1:
	IPPROTO_IDP                          = 22                                // in.h:163:1:
	IPPROTO_IGMP                         = 2                                 // in.h:156:1:
	IPPROTO_IP                           = 0                                 // in.h:153:1:
	IPPROTO_IPV6                         = 41                                // in.h:164:1:
	IPPROTO_MAX                          = 256                               // in.h:182:1:
	IPPROTO_ND                           = 77                                // in.h:174:1:
	IPPROTO_NONE                         = 59                                // in.h:171:1:
	IPPROTO_OSPF                         = 89                                // in.h:176:1:
	IPPROTO_PIM                          = 103                               // in.h:177:1:
	IPPROTO_PUP                          = 12                                // in.h:161:1:
	IPPROTO_RAW                          = 255                               // in.h:181:1:
	IPPROTO_ROUTING                      = 43                                // in.h:165:1:
	IPPROTO_RSVP                         = 46                                // in.h:167:1:
	IPPROTO_SCTP                         = 132                               // in.h:178:1:
	IPPROTO_TCP                          = 6                                 // in.h:159:1:
	IPPROTO_UDP                          = 17                                // in.h:162:1:
	IPSEC_PREF_NEVER                     = 0x01                              // in.h:941:1:
	IPSEC_PREF_REQUIRED                  = 0x02                              // in.h:942:1:
	IPSEC_PREF_UNIQUE                    = 0x04                              // in.h:943:1:
	IPV6_ADD_MEMBERSHIP                  = 0x9                               // in.h:1224:1:
	IPV6_BOUND_IF                        = 0x41                              // in.h:1307:1:
	IPV6_CHECKSUM                        = 0x18                              // in.h:1257:1:
	IPV6_DONTFRAG                        = 0x21                              // in.h:1260:1:
	IPV6_DROP_MEMBERSHIP                 = 0xa                               // in.h:1226:1:
	IPV6_DSTOPTS                         = 0xf                               // in.h:1234:1:
	IPV6_FLOWINFO_FLOWLABEL              = 0xffff0f00                        // in.h:447:1:
	IPV6_FLOWINFO_TCLASS                 = 0x0000f00f                        // in.h:448:1:
	IPV6_HOPLIMIT                        = 0xc                               // in.h:1231:1:
	IPV6_HOPOPTS                         = 0xe                               // in.h:1233:1:
	IPV6_JOIN_GROUP                      = 0x9                               // in.h:1202:1:
	IPV6_LEAVE_GROUP                     = 0xa                               // in.h:1204:1:
	IPV6_MULTICAST_HOPS                  = 0x7                               // in.h:1196:1:
	IPV6_MULTICAST_IF                    = 0x6                               // in.h:1193:1:
	IPV6_MULTICAST_LOOP                  = 0x8                               // in.h:1199:1:
	IPV6_NEXTHOP                         = 0xd                               // in.h:1232:1:
	IPV6_PAD1_OPT                        = 0                                 // in.h:1314:1:
	IPV6_PATHMTU                         = 0x25                              // in.h:1264:1:
	IPV6_PKTINFO                         = 0xb                               // in.h:1229:1:
	IPV6_PREFER_SRC_CGA                  = 0x00000020                        // in.h:1289:1:
	IPV6_PREFER_SRC_CGADEFAULT           = 16                                // in.h:1296:1:
	IPV6_PREFER_SRC_CGAMASK              = 48                                // in.h:1295:1:
	IPV6_PREFER_SRC_COA                  = 0x00000002                        // in.h:1285:1:
	IPV6_PREFER_SRC_DEFAULT              = 21                                // in.h:1301:1:
	IPV6_PREFER_SRC_HOME                 = 0x00000001                        // in.h:1284:1:
	IPV6_PREFER_SRC_MASK                 = 63                                // in.h:1298:1:
	IPV6_PREFER_SRC_MIPDEFAULT           = 1                                 // in.h:1292:1:
	IPV6_PREFER_SRC_MIPMASK              = 3                                 // in.h:1291:1:
	IPV6_PREFER_SRC_NONCGA               = 0x00000010                        // in.h:1288:1:
	IPV6_PREFER_SRC_PUBLIC               = 0x00000004                        // in.h:1286:1:
	IPV6_PREFER_SRC_TMP                  = 0x00000008                        // in.h:1287:1:
	IPV6_PREFER_SRC_TMPDEFAULT           = 4                                 // in.h:1294:1:
	IPV6_PREFER_SRC_TMPMASK              = 12                                // in.h:1293:1:
	IPV6_RECVDSTOPTS                     = 0x28                              // in.h:1271:1:
	IPV6_RECVHOPLIMIT                    = 0x13                              // in.h:1240:1:
	IPV6_RECVHOPOPTS                     = 0x14                              // in.h:1241:1:
	IPV6_RECVPATHMTU                     = 0x24                              // in.h:1263:1:
	IPV6_RECVPKTINFO                     = 0x12                              // in.h:1239:1:
	IPV6_RECVRTHDR                       = 0x16                              // in.h:1249:1:
	IPV6_RECVRTHDRDSTOPTS                = 0x17                              // in.h:1255:1:
	IPV6_RECVTCLASS                      = 0x19                              // in.h:1258:1:
	IPV6_RTHDR                           = 0x10                              // in.h:1236:1:
	IPV6_RTHDRDSTOPTS                    = 0x11                              // in.h:1237:1:
	IPV6_RTHDR_TYPE_0                    = 0                                 // in.h:1152:1:
	IPV6_SEC_OPT                         = 0x22                              // in.h:1261:1:
	IPV6_SRC_PREFERENCES                 = 0x23                              // in.h:1262:1:
	IPV6_TCLASS                          = 0x26                              // in.h:1265:1:
	IPV6_UNICAST_HOPS                    = 0x5                               // in.h:1190:1:
	IPV6_UNSPEC_SRC                      = 0x42                              // in.h:1308:1:
	IPV6_USE_MIN_MTU                     = 0x20                              // in.h:1259:1:
	IPV6_V6ONLY                          = 0x27                              // in.h:1266:1:
	IP_ADD_MEMBERSHIP                    = 0x13                              // in.h:921:1:
	IP_ADD_SOURCE_MEMBERSHIP             = 0x17                              // in.h:925:1:
	IP_BLOCK_SOURCE                      = 0x15                              // in.h:923:1:
	IP_BOUND_IF                          = 0x41                              // in.h:976:1:
	IP_BROADCAST                         = 0x106                             // in.h:994:1:
	IP_BROADCAST_TTL                     = 0x43                              // in.h:978:1:
	IP_DEFAULT_MULTICAST_LOOP            = 1                                 // in.h:1009:1:
	IP_DEFAULT_MULTICAST_TTL             = 1                                 // in.h:1008:1:
	IP_DHCPINIT_IF                       = 0x45                              // in.h:980:1:
	IP_DONTFRAG                          = 0x1b                              // in.h:934:1:
	IP_DONTROUTE                         = 0x105                             // in.h:990:1:
	IP_DROP_MEMBERSHIP                   = 0x14                              // in.h:922:1:
	IP_DROP_SOURCE_MEMBERSHIP            = 0x18                              // in.h:926:1:
	IP_HDRINCL                           = 2                                 // in.h:899:1:
	IP_MULTICAST_IF                      = 0x10                              // in.h:918:1:
	IP_MULTICAST_LOOP                    = 0x12                              // in.h:920:1:
	IP_MULTICAST_TTL                     = 0x11                              // in.h:919:1:
	IP_NEXTHOP                           = 0x19                              // in.h:927:1:
	IP_OPTIONS                           = 1                                 // in.h:896:1:
	IP_PKTINFO                           = 0x1a                              // in.h:932:1:
	IP_RECVDSTADDR                       = 0x7                               // in.h:911:1:
	IP_RECVIF                            = 0x9                               // in.h:913:1:
	IP_RECVOPTS                          = 0x5                               // in.h:909:1:
	IP_RECVPKTINFO                       = 0x1a                              // in.h:933:1:
	IP_RECVRETOPTS                       = 0x6                               // in.h:910:1:
	IP_RECVSLLA                          = 0xa                               // in.h:914:1:
	IP_RECVTOS                           = 0xc                               // in.h:916:1:
	IP_RECVTTL                           = 0xb                               // in.h:915:1:
	IP_RETOPTS                           = 0x8                               // in.h:912:1:
	IP_REUSEADDR                         = 0x104                             // in.h:986:1:
	IP_SEC_OPT                           = 0x22                              // in.h:940:1:
	IP_TOS                               = 3                                 // in.h:902:1:
	IP_TTL                               = 4                                 // in.h:906:1:
	IP_UNBLOCK_SOURCE                    = 0x16                              // in.h:924:1:
	IP_UNSPEC_SRC                        = 0x42                              // in.h:977:1:
	ITIMER_PROF                          = 2                                 // time.h:201:1:
	ITIMER_REAL                          = 0                                 // time.h:199:1:
	ITIMER_REALPROF                      = 3                                 // time.h:204:1:
	ITIMER_VIRTUAL                       = 1                                 // time.h:200:1:
	KMC_IDENTIFIER                       = 0x00400000                        // kmem.h:84:1:
	KMC_KMEM_ALLOC                       = 0x00200000                        // kmem.h:83:1:
	KMC_NODEBUG                          = 0x00020000                        // kmem.h:79:1:
	KMC_NOHASH                           = 0x00080000                        // kmem.h:81:1:
	KMC_NOMAGAZINE                       = 0x00040000                        // kmem.h:80:1:
	KMC_NOTOUCH                          = 0x00010000                        // kmem.h:78:1:
	KMC_PREFILL                          = 0x00800000                        // kmem.h:85:1:
	KMC_QCACHE                           = 0x00100000                        // kmem.h:82:1:
	KM_FLAGS                             = 0xffff                            // kmem.h:55:1:
	KM_NORMALPRI                         = 0x0008                            // kmem.h:51:1:
	KM_NOSLEEP                           = 0x0001                            // kmem.h:48:1:
	KM_NOSLEEP_LAZY                      = 9                                 // kmem.h:52:1:
	KM_PANIC                             = 0x0002                            // kmem.h:49:1:
	KM_PUSHPAGE                          = 0x0004                            // kmem.h:50:1:
	KM_SLEEP                             = 0x0000                            // kmem.h:47:1:
	KM_VMFLAGS                           = 0x00ff                            // kmem.h:53:1:
	KSTAT_DATA_CHAR                      = 0                                 // kstat.h:494:1:
	KSTAT_DATA_DOUBLE                    = 6                                 // kstat.h:536:1:
	KSTAT_DATA_FLOAT                     = 5                                 // kstat.h:535:1:
	KSTAT_DATA_INT32                     = 1                                 // kstat.h:495:1:
	KSTAT_DATA_INT64                     = 3                                 // kstat.h:497:1:
	KSTAT_DATA_LONG                      = 3                                 // kstat.h:505:1:
	KSTAT_DATA_LONGLONG                  = 3                                 // kstat.h:533:1:
	KSTAT_DATA_STRING                    = 9                                 // kstat.h:529:1:
	KSTAT_DATA_UINT32                    = 2                                 // kstat.h:496:1:
	KSTAT_DATA_UINT64                    = 4                                 // kstat.h:498:1:
	KSTAT_DATA_ULONG                     = 4                                 // kstat.h:506:1:
	KSTAT_DATA_ULONGLONG                 = 4                                 // kstat.h:534:1:
	KSTAT_FLAG_DORMANT                   = 0x10                              // kstat.h:312:1:
	KSTAT_FLAG_INVALID                   = 0x20                              // kstat.h:313:1:
	KSTAT_FLAG_LONGSTRINGS               = 0x40                              // kstat.h:314:1:
	KSTAT_FLAG_PERSISTENT                = 0x08                              // kstat.h:311:1:
	KSTAT_FLAG_VAR_SIZE                  = 0x02                              // kstat.h:309:1:
	KSTAT_FLAG_VIRTUAL                   = 0x01                              // kstat.h:308:1:
	KSTAT_FLAG_WRITABLE                  = 0x04                              // kstat.h:310:1:
	KSTAT_INTR_HARD                      = 0                                 // kstat.h:570:1:
	KSTAT_INTR_MULTSVC                   = 4                                 // kstat.h:574:1:
	KSTAT_INTR_SOFT                      = 1                                 // kstat.h:571:1:
	KSTAT_INTR_SPURIOUS                  = 3                                 // kstat.h:573:1:
	KSTAT_INTR_WATCHDOG                  = 2                                 // kstat.h:572:1:
	KSTAT_IOC_BASE                       = 19200                             // kstat.h:48:1:
	KSTAT_IOC_CHAIN_ID                   = 19201                             // kstat.h:50:1:
	KSTAT_IOC_READ                       = 19202                             // kstat.h:51:1:
	KSTAT_IOC_WRITE                      = 19203                             // kstat.h:52:1:
	KSTAT_NUM_INTRS                      = 5                                 // kstat.h:576:1:
	KSTAT_NUM_TYPES                      = 5                                 // kstat.h:232:1:
	KSTAT_READ                           = 0                                 // kstat.h:356:1:
	KSTAT_STRLEN                         = 31                                // kstat.h:62:1:
	KSTAT_TYPE_INTR                      = 2                                 // kstat.h:225:1:
	KSTAT_TYPE_IO                        = 3                                 // kstat.h:227:1:
	KSTAT_TYPE_NAMED                     = 1                                 // kstat.h:223:1:
	KSTAT_TYPE_RAW                       = 0                                 // kstat.h:221:1:
	KSTAT_TYPE_TIMER                     = 4                                 // kstat.h:229:1:
	KSTAT_WRITE                          = 1                                 // kstat.h:357:1:
	LINUX_SLL_BROADCAST                  = 1                                 // socket_impl.h:122:1:
	LINUX_SLL_HOST                       = 0                                 // socket_impl.h:121:1:
	LINUX_SLL_MULTICAST                  = 2                                 // socket_impl.h:123:1:
	LINUX_SLL_OTHERHOST                  = 3                                 // socket_impl.h:124:1:
	LINUX_SLL_OUTGOING                   = 4                                 // socket_impl.h:125:1:
	LOCK_HELD_VALUE                      = 0xff                              // machlock.h:54:1:
	LOCK_LEVEL                           = 10                                // machlock.h:110:1:
	LOOKUP_DIR                           = 0x01                              // vnode.h:1265:1:
	LOOKUP_HAVE_SYSATTR_DIR              = 0x08                              // vnode.h:1268:1:
	LOOKUP_XATTR                         = 0x02                              // vnode.h:1266:1:
	MAXBSIZE                             = 8192                              // param.h:249:1:
	MAXFIDSZ                             = 64                                // vfs.h:82:1:
	MAXFRAG                              = 8                                 // param.h:252:1:
	MAXLINK                              = 32767                             // param.h:126:1:
	MAXLINKNAMELEN                       = 32                                // param.h:209:1:
	MAXNAMELEN                           = 256                               // param.h:202:1:
	MAXOFFSET_T                          = 0x7fffffffffffffff                // param.h:258:1:
	MAXOFF_T                             = 0x7fffffffffffffff                // param.h:257:1:
	MAXPATHLEN                           = 1024                              // param.h:199:1:
	MAXPROJID                            = 2147483647                        // param.h:125:1:
	MAXSYMLINKS                          = 20                                // param.h:201:1:
	MAXUID                               = 2147483647                        // param.h:123:1:
	MAX_CANON                            = 256                               // param.h:89:1:
	MAX_INPUT                            = 512                               // param.h:86:1:
	MAX_ZONEID                           = 8191                              // zone.h:85:1:
	MAX_ZONES                            = 8192                              // zone.h:84:1:
	MCAST_BLOCK_SOURCE                   = 0x2b                              // in.h:1278:1:
	MCAST_EXCLUDE                        = 2                                 // in.h:1122:1:
	MCAST_INCLUDE                        = 1                                 // in.h:1121:1:
	MCAST_JOIN_GROUP                     = 0x29                              // in.h:1276:1:
	MCAST_JOIN_SOURCE_GROUP              = 0x2d                              // in.h:1280:1:
	MCAST_LEAVE_GROUP                    = 0x2a                              // in.h:1277:1:
	MCAST_LEAVE_SOURCE_GROUP             = 0x2e                              // in.h:1281:1:
	MCAST_UNBLOCK_SOURCE                 = 0x2c                              // in.h:1279:1:
	MICROSEC                             = 1000000                           // time.h:246:1:
	MILLISEC                             = 1000                              // time.h:245:1:
	MINEPHUID                            = 0x80000000                        // param.h:128:1:
	MIN_USERZONEID                       = 1                                 // zone.h:86:1:
	MIN_ZONEID                           = 0                                 // zone.h:87:1:
	MODEMASK                             = 07777                             // vnode.h:776:1:
	MO_DEFAULT                           = 1                                 // vfs.h:137:1:
	MO_EMPTY                             = 0x20                              // vfs.h:139:1:
	MO_HASVALUE                          = 0x04                              // vfs.h:135:1:
	MO_IGNORE                            = 0x08                              // vfs.h:136:1:
	MO_NODISPLAY                         = 0x02                              // vfs.h:134:1:
	MO_SET                               = 0x01                              // vfs.h:133:1:
	MO_TAG                               = 0x10                              // vfs.h:138:1:
	NADDR                                = 13                                // param.h:212:1:
	NANOSEC                              = 1000000000                        // time.h:247:1:
	NBBY                                 = 8                                 // select.h:103:1:
	NBPS                                 = 0x20000                           // param.h:165:1:
	NBPSCTR                              = 512                               // param.h:166:1:
	NCARGS                               = 2097152                           // param.h:294:1:
	NCARGS32                             = 0x100000                          // param.h:291:1:
	NCARGS64                             = 0x200000                          // param.h:292:1:
	NGROUPS_MAX_DEFAULT                  = 16                                // param.h:148:1:
	NGROUPS_OLDMAX                       = 32                                // param.h:143:1:
	NGROUPS_UMAX                         = 1024                              // param.h:142:1:
	NGROUPS_UMIN                         = 0                                 // param.h:141:1:
	NMOUNT                               = 40                                // param.h:130:1:
	NOFILE                               = 20                                // param.h:132:1:
	NZERO                                = 20                                // param.h:153:1:
	OLD_MAXFIDSZ                         = 16                                // vfs.h:83:1:
	PERMMASK                             = 00777                             // vnode.h:777:1:
	PIL_MAX                              = 15                                // machlock.h:107:1:
	PIPE_BUF                             = 5120                              // param.h:221:1:
	PIPE_MAX                             = 5120                              // param.h:225:1:
	PREMOTE                              = 39                                // param.h:185:1:
	PRIO_CONTRACT                        = 9                                 // resource.h:66:1:
	PRIO_GROUP                           = 3                                 // resource.h:60:1:
	PRIO_LWP                             = 5                                 // resource.h:62:1:
	PRIO_PGRP                            = 1                                 // resource.h:58:1:
	PRIO_PROCESS                         = 0                                 // resource.h:57:1:
	PRIO_PROJECT                         = 7                                 // resource.h:64:1:
	PRIO_SESSION                         = 4                                 // resource.h:61:1:
	PRIO_TASK                            = 6                                 // resource.h:63:1:
	PRIO_USER                            = 2                                 // resource.h:59:1:
	PRIO_ZONE                            = 8                                 // resource.h:65:1:
	PROTO_SDP                            = 257                               // in.h:185:1:
	PTR24_ALIGN                          = 32                                // machlock.h:133:1:
	PTR24_BASE                           = 0xe0000000                        // machlock.h:134:1:
	PTR24_LSB                            = 5                                 // machlock.h:131:1:
	PTR24_MSB                            = 29                                // machlock.h:132:1:
	P_MYID                               = -1                                // types.h:632:1:
	REG_LABEL_BP                         = 2                                 // machtypes.h:44:1:
	REG_LABEL_MAX                        = 8                                 // machtypes.h:51:1:
	REG_LABEL_PC                         = 0                                 // machtypes.h:42:1:
	REG_LABEL_R12                        = 4                                 // machtypes.h:47:1:
	REG_LABEL_R13                        = 5                                 // machtypes.h:48:1:
	REG_LABEL_R14                        = 6                                 // machtypes.h:49:1:
	REG_LABEL_R15                        = 7                                 // machtypes.h:50:1:
	REG_LABEL_RBX                        = 3                                 // machtypes.h:46:1:
	REG_LABEL_SP                         = 1                                 // machtypes.h:43:1:
	RLIMIT_AS                            = 6                                 // resource.h:78:1:
	RLIMIT_CORE                          = 4                                 // resource.h:75:1:
	RLIMIT_CPU                           = 0                                 // resource.h:71:1:
	RLIMIT_DATA                          = 2                                 // resource.h:73:1:
	RLIMIT_FSIZE                         = 1                                 // resource.h:72:1:
	RLIMIT_NOFILE                        = 5                                 // resource.h:76:1:
	RLIMIT_STACK                         = 3                                 // resource.h:74:1:
	RLIMIT_VMEM                          = 6                                 // resource.h:77:1:
	RLIM_NLIMITS                         = 7                                 // resource.h:80:1:
	RLIM_NSAVED                          = 7                                 // resource.h:162:1:
	RUSAGE_CHILDREN                      = -1                                // resource.h:230:1:
	RUSAGE_LWP                           = 1                                 // resource.h:229:1:
	RUSAGE_SELF                          = 0                                 // resource.h:228:1:
	RWST_SIG                             = 0x02                              // rwstlock.h:56:1:
	RWST_TRYENTER                        = 0x01                              // rwstlock.h:55:1:
	SCTRSHFT                             = 9                                 // param.h:168:1:
	SEC                                  = 1                                 // time.h:244:1:
	ST_NOSUID                            = 0x02                              // statvfs.h:157:1:
	ST_NOTRUNC                           = 0x04                              // statvfs.h:158:1:
	ST_RDONLY                            = 0x01                              // statvfs.h:156:1:
	SYNC_ALL                             = 0x04                              // vfs.h:609:1:
	SYNC_ATTR                            = 0x01                              // vfs.h:607:1:
	SYNC_CLOSE                           = 0x02                              // vfs.h:608:1:
	SYSNAME                              = 9                                 // param.h:184:1:
	TIMER_ABSTIME                        = 0x1                               // time_impl.h:134:1:
	TIMER_RELTIME                        = 0x0                               // time_impl.h:133:1:
	TIME_UTC                             = 0x1                               // time.h:306:1:
	TYPICALMAXPATHLEN                    = 64                                // param.h:200:1:
	UA_FASTREBOOT_DEFAULT                = 0x01                              // uadmin.h:138:1:
	UA_FASTREBOOT_ONPANIC                = 0x02                              // uadmin.h:139:1:
	UBSIZE                               = 512                               // param.h:167:1:
	UID_DLADM                            = 15                                // param.h:98:1:
	UID_NETADM                           = 16                                // param.h:99:1:
	UID_NOACCESS                         = 60002                             // param.h:101:1:
	UID_NOBODY                           = 60001                             // param.h:94:1:
	UID_UNKNOWN                          = 96                                // param.h:96:1:
	UIOA_ALLOC                           = 0x0001                            // uio.h:194:1:
	UIOA_CLR                             = -16                               // uio.h:199:1:
	UIOA_ENABLED                         = 0x0004                            // uio.h:196:1:
	UIOA_FINI                            = 0x0008                            // uio.h:197:1:
	UIOA_INIT                            = 0x0002                            // uio.h:195:1:
	UIOA_IOV_MAX                         = 16                                // uio.h:112:1:
	UIOA_POLL                            = 0x0010                            // uio.h:201:1:
	UIO_ASYNC                            = 0x0002                            // uio.h:237:1:
	UIO_COPY_CACHED                      = 0x0001                            // uio.h:235:1:
	UIO_COPY_DEFAULT                     = 0x0000                            // uio.h:234:1:
	UIO_XUIO                             = 0x0004                            // uio.h:238:1:
	VDIROPEN                             = 0x800                             // vnode.h:374:1:
	VDUP                                 = 0x08                              // vnode.h:340:1:
	VEXEC                                = 00100                             // vnode.h:774:1:
	VFSFT_ACCESS_FILTER                  = 0x100000080                       // vfs.h:279:1:
	VFSFT_ACEMASKONACCESS                = 0x100000020                       // vfs.h:277:1:
	VFSFT_ACLONCREATE                    = 0x100000010                       // vfs.h:276:1:
	VFSFT_CASEINSENSITIVE                = 0x100000002                       // vfs.h:273:1:
	VFSFT_DIRENTFLAGS                    = 0x100000008                       // vfs.h:275:1:
	VFSFT_NOCASESENSITIVE                = 0x100000004                       // vfs.h:274:1:
	VFSFT_REPARSE                        = 0x100000100                       // vfs.h:280:1:
	VFSFT_SYSATTR_VIEWS                  = 0x100000040                       // vfs.h:278:1:
	VFSFT_XVATTR                         = 0x100000001                       // vfs.h:272:1:
	VFSFT_ZEROCOPY_SUPPORTED             = 0x100000200                       // vfs.h:281:1:
	VFSNAME_FREEVFS                      = "freevfs"                         // vfs.h:370:1:
	VFSNAME_MOUNT                        = "mount"                           // vfs.h:363:1:
	VFSNAME_MOUNTROOT                    = "mountroot"                       // vfs.h:369:1:
	VFSNAME_ROOT                         = "root"                            // vfs.h:365:1:
	VFSNAME_STATVFS                      = "statvfs"                         // vfs.h:366:1:
	VFSNAME_SYNC                         = "sync"                            // vfs.h:367:1:
	VFSNAME_UNMOUNT                      = "unmount"                         // vfs.h:364:1:
	VFSNAME_VGET                         = "vget"                            // vfs.h:368:1:
	VFSNAME_VNSTATE                      = "vnstate"                         // vfs.h:371:1:
	VFSSP_VERBATIM                       = 0x1                               // vfs.h:426:1:
	VFS_CREATEOPT                        = 0x08                              // vfs.h:144:1:
	VFS_DISPLAY                          = 0x02                              // vfs.h:142:1:
	VFS_NBMAND                           = 0x200                             // vfs.h:253:1:
	VFS_NODEVICES                        = 0x800                             // vfs.h:255:1:
	VFS_NODISPLAY                        = 0x04                              // vfs.h:143:1:
	VFS_NOEXEC                           = 0x1000                            // vfs.h:256:1:
	VFS_NOFORCEOPT                       = 0x01                              // vfs.h:141:1:
	VFS_NOMNTPT                          = "unspecified_mountpoint"          // vfs.h:261:1:
	VFS_NOMNTTAB                         = 0x02                              // vfs.h:246:1:
	VFS_NORESOURCE                       = "unspecified_resource"            // vfs.h:260:1:
	VFS_NOSETUID                         = 0x08                              // vfs.h:247:1:
	VFS_NOTRUNC                          = 0x20                              // vfs.h:249:1:
	VFS_PXFS                             = 0x80                              // vfs.h:251:1:
	VFS_RDONLY                           = 0x01                              // vfs.h:245:1:
	VFS_REMOUNT                          = 0x10                              // vfs.h:248:1:
	VFS_STATS                            = 0x2000                            // vfs.h:257:1:
	VFS_UNLINKABLE                       = 0x40                              // vfs.h:250:1:
	VFS_UNMOUNTED                        = 0x100                             // vfs.h:252:1:
	VFS_XATTR                            = 0x400                             // vfs.h:254:1:
	VFS_XID                              = 0x4000                            // vfs.h:258:1:
	VISSWAP                              = 0x40                              // vnode.h:343:1:
	VISSWAPFS                            = 0x20000                           // vnode.h:402:1:
	VMC_DUMPSAFE                         = 0x00200000                        // vmem.h:78:1:
	VMC_FLAGS                            = 0xFFFF0000                        // vmem.h:88:1:
	VMC_IDENTIFIER                       = 0x00040000                        // vmem.h:77:1:
	VMC_NO_QCACHE                        = 0x00020000                        // vmem.h:76:1:
	VMC_POPULATOR                        = 0x00010000                        // vmem.h:75:1:
	VMC_XALIGN                           = 0x00100000                        // vmem.h:87:1:
	VMC_XALLOC                           = 0x00080000                        // vmem.h:86:1:
	VMEM_ALLOC                           = 0x01                              // vmem.h:93:1:
	VMEM_FREE                            = 0x02                              // vmem.h:94:1:
	VMEM_REENTRANT                       = 0x80000000                        // vmem.h:112:1:
	VMEM_ROTOR                           = 0x20                              // vmem.h:100:1:
	VMEM_SPAN                            = 0x10                              // vmem.h:99:1:
	VMEM_WALKER                          = 0x40                              // vmem.h:101:1:
	VMODSORT                             = 65536                             // vnode.h:398:1:
	VM_ABORT                             = 0x00002000                        // vmem.h:62:1:
	VM_BESTFIT                           = 0x00000100                        // vmem.h:46:1:
	VM_ENDALLOC                          = 0x00004000                        // vmem.h:68:1:
	VM_FIRSTFIT                          = 0x00000200                        // vmem.h:47:1:
	VM_FLAGS                             = 0x0000FFFF                        // vmem.h:70:1:
	VM_KMFLAGS                           = 0x000000ff                        // vmem.h:44:1:
	VM_MEMLOAD                           = 0x00000800                        // vmem.h:55:1:
	VM_NEXTFIT                           = 0x00000400                        // vmem.h:48:1:
	VM_NORELOC                           = 0x00001000                        // vmem.h:56:1:
	VM_NORMALPRI                         = 0x00000008                        // vmem.h:43:1:
	VM_NOSLEEP                           = 0x00000001                        // vmem.h:40:1:
	VM_PANIC                             = 0x00000002                        // vmem.h:41:1:
	VM_PUSHPAGE                          = 0x00000004                        // vmem.h:42:1:
	VM_SLEEP                             = 0x00000000                        // vmem.h:39:1:
	VNOCACHE                             = 0x02                              // vnode.h:338:1:
	VNODE_ALIGN                          = 64                                // vnode.h:326:1:
	VNODE_ALIGN_LOG2                     = 8                                 // vnode.h:329:1:
	VNOMAP                               = 0x04                              // vnode.h:339:1:
	VNOMOUNT                             = 0x20                              // vnode.h:342:1:
	VNOSWAP                              = 0x10                              // vnode.h:341:1:
	VOPNAME_ACCESS                       = "access"                          // vnode.h:1220:1:
	VOPNAME_ADDMAP                       = "addmap"                          // vnode.h:1244:1:
	VOPNAME_CLOSE                        = "close"                           // vnode.h:1213:1:
	VOPNAME_CMP                          = "cmp"                             // vnode.h:1237:1:
	VOPNAME_CREATE                       = "create"                          // vnode.h:1222:1:
	VOPNAME_DELMAP                       = "delmap"                          // vnode.h:1245:1:
	VOPNAME_DISPOSE                      = "dispose"                         // vnode.h:1251:1:
	VOPNAME_DUMP                         = "dump"                            // vnode.h:1247:1:
	VOPNAME_DUMPCTL                      = "dumpctl"                         // vnode.h:1250:1:
	VOPNAME_FID                          = "fid"                             // vnode.h:1233:1:
	VOPNAME_FRLOCK                       = "frlock"                          // vnode.h:1238:1:
	VOPNAME_FSYNC                        = "fsync"                           // vnode.h:1231:1:
	VOPNAME_GETATTR                      = "getattr"                         // vnode.h:1218:1:
	VOPNAME_GETPAGE                      = "getpage"                         // vnode.h:1241:1:
	VOPNAME_GETSECATTR                   = "getsecattr"                      // vnode.h:1252:1:
	VOPNAME_INACTIVE                     = "inactive"                        // vnode.h:1232:1:
	VOPNAME_IOCTL                        = "ioctl"                           // vnode.h:1216:1:
	VOPNAME_LINK                         = "link"                            // vnode.h:1224:1:
	VOPNAME_LOOKUP                       = "lookup"                          // vnode.h:1221:1:
	VOPNAME_MAP                          = "map"                             // vnode.h:1243:1:
	VOPNAME_MKDIR                        = "mkdir"                           // vnode.h:1226:1:
	VOPNAME_OPEN                         = "open"                            // vnode.h:1212:1:
	VOPNAME_PAGEIO                       = "pageio"                          // vnode.h:1249:1:
	VOPNAME_PATHCONF                     = "pathconf"                        // vnode.h:1248:1:
	VOPNAME_POLL                         = "poll"                            // vnode.h:1246:1:
	VOPNAME_PUTPAGE                      = "putpage"                         // vnode.h:1242:1:
	VOPNAME_READ                         = "read"                            // vnode.h:1214:1:
	VOPNAME_READDIR                      = "readdir"                         // vnode.h:1228:1:
	VOPNAME_READLINK                     = "readlink"                        // vnode.h:1230:1:
	VOPNAME_REALVP                       = "realvp"                          // vnode.h:1240:1:
	VOPNAME_REMOVE                       = "remove"                          // vnode.h:1223:1:
	VOPNAME_RENAME                       = "rename"                          // vnode.h:1225:1:
	VOPNAME_REQZCBUF                     = "reqzcbuf"                        // vnode.h:1256:1:
	VOPNAME_RETZCBUF                     = "retzcbuf"                        // vnode.h:1257:1:
	VOPNAME_RMDIR                        = "rmdir"                           // vnode.h:1227:1:
	VOPNAME_RWLOCK                       = "rwlock"                          // vnode.h:1234:1:
	VOPNAME_RWUNLOCK                     = "rwunlock"                        // vnode.h:1235:1:
	VOPNAME_SEEK                         = "seek"                            // vnode.h:1236:1:
	VOPNAME_SETATTR                      = "setattr"                         // vnode.h:1219:1:
	VOPNAME_SETFL                        = "setfl"                           // vnode.h:1217:1:
	VOPNAME_SETSECATTR                   = "setsecattr"                      // vnode.h:1253:1:
	VOPNAME_SHRLOCK                      = "shrlock"                         // vnode.h:1254:1:
	VOPNAME_SPACE                        = "space"                           // vnode.h:1239:1:
	VOPNAME_SYMLINK                      = "symlink"                         // vnode.h:1229:1:
	VOPNAME_VNEVENT                      = "vnevent"                         // vnode.h:1255:1:
	VOPNAME_WRITE                        = "write"                           // vnode.h:1215:1:
	VOPSTATS_STR                         = "vopstats_"                       // vnode.h:75:1:
	VPXFS                                = 0x2000                            // vnode.h:382:1:
	VREAD                                = 00400                             // vnode.h:772:1:
	VROOT                                = 0x01                              // vnode.h:337:1:
	VSA_ACE                              = 0x0010                            // vnode.h:858:1:
	VSA_ACECNT                           = 0x0020                            // vnode.h:859:1:
	VSA_ACE_ACLFLAGS                     = 0x0080                            // vnode.h:861:1:
	VSA_ACE_ALLTYPES                     = 0x0040                            // vnode.h:860:1:
	VSA_ACL                              = 0x0001                            // vnode.h:854:1:
	VSA_ACLCNT                           = 0x0002                            // vnode.h:855:1:
	VSA_DFACL                            = 0x0004                            // vnode.h:856:1:
	VSA_DFACLCNT                         = 0x0008                            // vnode.h:857:1:
	VSGID                                = 02000                             // vnode.h:766:1:
	VSUID                                = 04000                             // vnode.h:765:1:
	VSVTX                                = 01000                             // vnode.h:767:1:
	VSWAPLIKE                            = 0x80                              // vnode.h:344:1:
	VSW_CANLOFI                          = 0x80                              // vfs.h:417:1:
	VSW_CANREMOUNT                       = 0x04                              // vfs.h:412:1:
	VSW_CANRWRO                          = 0x02                              // vfs.h:411:1:
	VSW_HASPROTO                         = 0x01                              // vfs.h:410:1:
	VSW_INSTALLED                        = 0x8000                            // vfs.h:421:1:
	VSW_MOUNTDEV                         = 0x200                             // vfs.h:419:1:
	VSW_NOTZONESAFE                      = 0x08                              // vfs.h:413:1:
	VSW_STATS                            = 0x20                              // vfs.h:415:1:
	VSW_VOLATILEDEV                      = 0x10                              // vfs.h:414:1:
	VSW_XID                              = 0x40                              // vfs.h:416:1:
	VSW_ZMOUNT                           = 0x100                             // vfs.h:418:1:
	VTRAVERSE                            = 0x80000                           // vnode.h:419:1:
	VVFSLOCK                             = 0x100                             // vnode.h:362:1:
	VVFSWAIT                             = 0x200                             // vnode.h:363:1:
	VVMEXEC                              = 0x1000                            // vnode.h:380:1:
	VVMLOCK                              = 0x400                             // vnode.h:368:1:
	VWRITE                               = 00200                             // vnode.h:773:1:
	V_ACE_MASK                           = 0x1                               // vnode.h:782:1:
	V_APPEND                             = 0x2                               // vnode.h:783:1:
	V_FALSE                              = 0                                 // vnode.h:837:1:
	V_LOCALITY                           = 0x8000                            // vnode.h:390:1:
	V_RDDIR_ACCFILTER                    = 0x02                              // vnode.h:1274:1:
	V_RDDIR_ENTFLAGS                     = 0x01                              // vnode.h:1273:1:
	V_SYSATTR                            = 0x40000                           // vnode.h:411:1:
	V_TRUE                               = 1                                 // vnode.h:836:1:
	V_WRITELOCK_FALSE                    = 0                                 // vnode.h:1281:1:
	V_WRITELOCK_TRUE                     = 1                                 // vnode.h:1280:1:
	V_XATTRDIR                           = 0x4000                            // vnode.h:386:1:
	XAT0_APPENDONLY                      = 0x00000080                        // vnode.h:650:1:
	XAT0_ARCHIVE                         = 0x00000002                        // vnode.h:644:1:
	XAT0_AV_MODIFIED                     = 0x00000800                        // vnode.h:654:1:
	XAT0_AV_QUARANTINED                  = 0x00000400                        // vnode.h:653:1:
	XAT0_AV_SCANSTAMP                    = 0x00001000                        // vnode.h:655:1:
	XAT0_CREATETIME                      = 0x00000001                        // vnode.h:643:1:
	XAT0_GEN                             = 0x00004000                        // vnode.h:657:1:
	XAT0_HIDDEN                          = 0x00000010                        // vnode.h:647:1:
	XAT0_IMMUTABLE                       = 0x00000040                        // vnode.h:649:1:
	XAT0_INDEX                           = 0                                 // vnode.h:642:1:
	XAT0_NODUMP                          = 0x00000100                        // vnode.h:651:1:
	XAT0_NOUNLINK                        = 0x00000020                        // vnode.h:648:1:
	XAT0_OFFLINE                         = 0x00008000                        // vnode.h:658:1:
	XAT0_OPAQUE                          = 0x00000200                        // vnode.h:652:1:
	XAT0_PROJID                          = 0x00040000                        // vnode.h:661:1:
	XAT0_PROJINHERIT                     = 0x00020000                        // vnode.h:660:1:
	XAT0_READONLY                        = 0x00000008                        // vnode.h:646:1:
	XAT0_REPARSE                         = 0x00002000                        // vnode.h:656:1:
	XAT0_SPARSE                          = 0x00010000                        // vnode.h:659:1:
	XAT0_SYSTEM                          = 0x00000004                        // vnode.h:645:1:
	XAT_APPENDONLY                       = 128                               // vnode.h:694:1:
	XAT_ARCHIVE                          = 2                                 // vnode.h:688:1:
	XAT_AV_MODIFIED                      = 2048                              // vnode.h:698:1:
	XAT_AV_QUARANTINED                   = 1024                              // vnode.h:697:1:
	XAT_AV_SCANSTAMP                     = 4096                              // vnode.h:699:1:
	XAT_CREATETIME                       = 1                                 // vnode.h:687:1:
	XAT_GEN                              = 16384                             // vnode.h:701:1:
	XAT_HIDDEN                           = 16                                // vnode.h:691:1:
	XAT_IMMUTABLE                        = 64                                // vnode.h:693:1:
	XAT_NODUMP                           = 256                               // vnode.h:695:1:
	XAT_NOUNLINK                         = 32                                // vnode.h:692:1:
	XAT_OFFLINE                          = 32768                             // vnode.h:702:1:
	XAT_OPAQUE                           = 512                               // vnode.h:696:1:
	XAT_PROJID                           = 262144                            // vnode.h:705:1:
	XAT_PROJINHERIT                      = 131072                            // vnode.h:704:1:
	XAT_READONLY                         = 8                                 // vnode.h:690:1:
	XAT_REPARSE                          = 8192                              // vnode.h:700:1:
	XAT_SPARSE                           = 65536                             // vnode.h:703:1:
	XAT_SYSTEM                           = 4                                 // vnode.h:689:1:
	XVA_MAGIC                            = 0x78766174                        // vnode.h:504:1:
	XVA_MAPSIZE                          = 3                                 // vnode.h:503:1:
	XVA_MASK                             = 0xffffffff                        // vnode.h:670:1:
	XVA_SHFT                             = 32                                // vnode.h:671:1:
	ZCF_NET_EXCL                         = 0x1                               // zone.h:348:1:
	ZE_AREMOUNTS                         = 2                                 // zone.h:250:1:
	ZE_CHROOTED                          = 1                                 // zone.h:249:1:
	ZE_LABELINUSE                        = 3                                 // zone.h:251:1:
	ZE_UNKNOWN                           = 0                                 // zone.h:248:1:
	ZF_HASHED_LABEL                      = 0x2                               // zone.h:342:1:
	ZF_IS_SCRATCH                        = 0x4                               // zone.h:343:1:
	ZF_NET_EXCL                          = 0x8                               // zone.h:344:1:
	ZF_REFCOUNTS_LOGGED                  = 0x1                               // zone.h:336:1:
	ZONEID_WIDTH                         = 4                                 // zone.h:89:1:
	ZONENAME_MAX                         = 64                                // zone.h:311:1:
	ZONENAME_REGEXP                      = "[a-zA-Z0-9][-_.a-zA-Z0-9]{0,62}" // zone.h:319:1:
	ZONES_TMPDIR                         = "/var/run/zones"                  // zone.h:324:1:
	ZONE_ADD_DATALINK                    = 10                                // zone.h:107:1:
	ZONE_ATTR_APP_SVC_CT                 = 31                                // zone.h:145:1:
	ZONE_ATTR_BOOTARGS                   = 10                                // zone.h:128:1:
	ZONE_ATTR_BRAND                      = 11                                // zone.h:129:1:
	ZONE_ATTR_BRAND_ATTRS                = 32768                             // zone.h:149:1:
	ZONE_ATTR_DID                        = 30                                // zone.h:144:1:
	ZONE_ATTR_FLAGS                      = 14                                // zone.h:132:1:
	ZONE_ATTR_FS_ALLOWED                 = 16                                // zone.h:134:1:
	ZONE_ATTR_HOSTID                     = 15                                // zone.h:133:1:
	ZONE_ATTR_INITNAME                   = 9                                 // zone.h:127:1:
	ZONE_ATTR_INITNORESTART              = 20                                // zone.h:138:1:
	ZONE_ATTR_INITPID                    = 7                                 // zone.h:125:1:
	ZONE_ATTR_INITREBOOT                 = 23                                // zone.h:141:1:
	ZONE_ATTR_INITRESTART0               = 22                                // zone.h:140:1:
	ZONE_ATTR_NAME                       = 2                                 // zone.h:120:1:
	ZONE_ATTR_NETWORK                    = 17                                // zone.h:135:1:
	ZONE_ATTR_POOLID                     = 6                                 // zone.h:124:1:
	ZONE_ATTR_PRIVSET                    = 4                                 // zone.h:122:1:
	ZONE_ATTR_ROOT                       = 1                                 // zone.h:119:1:
	ZONE_ATTR_SCHED_CLASS                = 13                                // zone.h:131:1:
	ZONE_ATTR_SCHED_FIXEDHI              = 32                                // zone.h:146:1:
	ZONE_ATTR_SECFLAGS                   = 21                                // zone.h:139:1:
	ZONE_ATTR_SLBL                       = 8                                 // zone.h:126:1:
	ZONE_ATTR_STATUS                     = 3                                 // zone.h:121:1:
	ZONE_ATTR_UNIQID                     = 5                                 // zone.h:123:1:
	ZONE_BOOT                            = 7                                 // zone.h:104:1:
	ZONE_CB_NAME                         = "zonename"                        // zone.h:163:1:
	ZONE_CB_NEWSTATE                     = "newstate"                        // zone.h:164:1:
	ZONE_CB_OLDSTATE                     = "oldstate"                        // zone.h:165:1:
	ZONE_CB_TIMESTAMP                    = "when"                            // zone.h:166:1:
	ZONE_CB_ZONEID                       = "zoneid"                          // zone.h:167:1:
	ZONE_CHECK_DATALINK                  = 12                                // zone.h:109:1:
	ZONE_CREATE                          = 0                                 // zone.h:97:1:
	ZONE_DEL_DATALINK                    = 11                                // zone.h:108:1:
	ZONE_DESTROY                         = 1                                 // zone.h:98:1:
	ZONE_ENTER                           = 3                                 // zone.h:100:1:
	ZONE_EVENT_CHANNEL                   = "com.sun:zones:status"            // zone.h:153:1:
	ZONE_EVENT_INITIALIZED               = "initialized"                     // zone.h:158:1:
	ZONE_EVENT_READY                     = "ready"                           // zone.h:159:1:
	ZONE_EVENT_RUNNING                   = "running"                         // zone.h:160:1:
	ZONE_EVENT_SHUTTING_DOWN             = "shutting_down"                   // zone.h:161:1:
	ZONE_EVENT_STATUS_CLASS              = "status"                          // zone.h:154:1:
	ZONE_EVENT_STATUS_SUBCLASS           = "change"                          // zone.h:155:1:
	ZONE_EVENT_UNINITIALIZED             = "uninitialized"                   // zone.h:157:1:
	ZONE_FS_ALLOWED_MAX                  = 1024                              // zone.h:151:1:
	ZONE_GETATTR                         = 2                                 // zone.h:99:1:
	ZONE_LIST                            = 4                                 // zone.h:101:1:
	ZONE_LIST_DATALINK                   = 13                                // zone.h:110:1:
	ZONE_LOOKUP                          = 6                                 // zone.h:103:1:
	ZONE_NETWORK_ADDRESS                 = 1                                 // zone.h:351:1:
	ZONE_NETWORK_DEFROUTER               = 2                                 // zone.h:352:1:
	ZONE_NET_ADDRNAME                    = "address"                         // zone.h:354:1:
	ZONE_NET_RTRNAME                     = "route"                           // zone.h:355:1:
	ZONE_SETATTR                         = 9                                 // zone.h:106:1:
	ZONE_SHUTDOWN                        = 5                                 // zone.h:102:1:
	ZONE_SUBPROC_FATAL                   = 255                               // zone.h:210:1:
	ZONE_SUBPROC_NOTCOMPLETE             = 254                               // zone.h:209:1:
	ZONE_SUBPROC_OK                      = 0                                 // zone.h:207:1:
	ZONE_SUBPROC_USAGE                   = 253                               // zone.h:208:1:
	ZONE_VERSION                         = 8                                 // zone.h:105:1:
	X_ACL_ACE_ENABLED                    = 0x2                               // unistd.h:349:1:
	X_ACL_ACLENT_ENABLED                 = 0x1                               // unistd.h:348:1:
	X_ALIGNMENT_REQUIRED                 = 1                                 // isa_defs.h:262:1:
	X_AVL_H                              = 0                                 // avl.h:31:1:
	X_AVL_IMPL_H                         = 0                                 // avl_impl.h:28:1:
	X_BIT_FIELDS_LTOH                    = 0                                 // isa_defs.h:245:1:
	X_BOOL_ALIGNMENT                     = 1                                 // isa_defs.h:248:1:
	X_CASE_INSENSITIVE                   = 0x2                               // unistd.h:342:1:
	X_CASE_SENSITIVE                     = 0x1                               // unistd.h:341:1:
	X_CHAR_ALIGNMENT                     = 1                                 // isa_defs.h:249:1:
	X_CHAR_IS_SIGNED                     = 0                                 // isa_defs.h:247:1:
	X_CLOCKID_T                          = 0                                 // types.h:568:1:
	X_CLOCK_T                            = 0                                 // types.h:563:1:
	X_COND_MAGIC                         = 0x4356                            // types.h:426:1:
	X_CS_LFS64_CFLAGS                    = 72                                // unistd.h:61:1:
	X_CS_LFS64_LDFLAGS                   = 73                                // unistd.h:62:1:
	X_CS_LFS64_LIBS                      = 74                                // unistd.h:63:1:
	X_CS_LFS64_LINTFLAGS                 = 75                                // unistd.h:64:1:
	X_CS_LFS_CFLAGS                      = 68                                // unistd.h:56:1:
	X_CS_LFS_LDFLAGS                     = 69                                // unistd.h:57:1:
	X_CS_LFS_LIBS                        = 70                                // unistd.h:58:1:
	X_CS_LFS_LINTFLAGS                   = 71                                // unistd.h:59:1:
	X_CS_PATH                            = 65                                // unistd.h:50:1:
	X_CS_POSIX_V6_ILP32_OFF32_CFLAGS     = 800                               // unistd.h:85:1:
	X_CS_POSIX_V6_ILP32_OFF32_LDFLAGS    = 801                               // unistd.h:86:1:
	X_CS_POSIX_V6_ILP32_OFF32_LIBS       = 802                               // unistd.h:87:1:
	X_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS  = 803                               // unistd.h:88:1:
	X_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS    = 804                               // unistd.h:89:1:
	X_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS   = 805                               // unistd.h:90:1:
	X_CS_POSIX_V6_ILP32_OFFBIG_LIBS      = 806                               // unistd.h:91:1:
	X_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 807                               // unistd.h:92:1:
	X_CS_POSIX_V6_LP64_OFF64_CFLAGS      = 808                               // unistd.h:93:1:
	X_CS_POSIX_V6_LP64_OFF64_LDFLAGS     = 809                               // unistd.h:94:1:
	X_CS_POSIX_V6_LP64_OFF64_LIBS        = 810                               // unistd.h:95:1:
	X_CS_POSIX_V6_LP64_OFF64_LINTFLAGS   = 811                               // unistd.h:96:1:
	X_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS    = 812                               // unistd.h:97:1:
	X_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS   = 813                               // unistd.h:98:1:
	X_CS_POSIX_V6_LPBIG_OFFBIG_LIBS      = 814                               // unistd.h:99:1:
	X_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 815                               // unistd.h:100:1:
	X_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS  = 816                               // unistd.h:101:1:
	X_CS_XBS5_ILP32_OFF32_CFLAGS         = 700                               // unistd.h:67:1:
	X_CS_XBS5_ILP32_OFF32_LDFLAGS        = 701                               // unistd.h:68:1:
	X_CS_XBS5_ILP32_OFF32_LIBS           = 702                               // unistd.h:69:1:
	X_CS_XBS5_ILP32_OFF32_LINTFLAGS      = 703                               // unistd.h:70:1:
	X_CS_XBS5_ILP32_OFFBIG_CFLAGS        = 705                               // unistd.h:71:1:
	X_CS_XBS5_ILP32_OFFBIG_LDFLAGS       = 706                               // unistd.h:72:1:
	X_CS_XBS5_ILP32_OFFBIG_LIBS          = 707                               // unistd.h:73:1:
	X_CS_XBS5_ILP32_OFFBIG_LINTFLAGS     = 708                               // unistd.h:74:1:
	X_CS_XBS5_LP64_OFF64_CFLAGS          = 709                               // unistd.h:75:1:
	X_CS_XBS5_LP64_OFF64_LDFLAGS         = 710                               // unistd.h:76:1:
	X_CS_XBS5_LP64_OFF64_LIBS            = 711                               // unistd.h:77:1:
	X_CS_XBS5_LP64_OFF64_LINTFLAGS       = 712                               // unistd.h:78:1:
	X_CS_XBS5_LPBIG_OFFBIG_CFLAGS        = 713                               // unistd.h:79:1:
	X_CS_XBS5_LPBIG_OFFBIG_LDFLAGS       = 714                               // unistd.h:80:1:
	X_CS_XBS5_LPBIG_OFFBIG_LIBS          = 715                               // unistd.h:81:1:
	X_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS     = 716                               // unistd.h:82:1:
	X_DMA_USES_PHYSADDR                  = 0                                 // isa_defs.h:281:1:
	X_DONT_USE_1275_GENERIC_NAMES        = 0                                 // isa_defs.h:287:1:
	X_DOUBLE_ALIGNMENT                   = 8                                 // isa_defs.h:256:1:
	X_DOUBLE_COMPLEX_ALIGNMENT           = 8                                 // isa_defs.h:257:1:
	X_DTRACE_VERSION                     = 1                                 // feature_tests.h:490:1:
	X_FILE_OFFSET_BITS                   = 64                                // <builtin>:25:1:
	X_FIRMWARE_NEEDS_FDISK               = 0                                 // isa_defs.h:282:1:
	X_FLOAT_ALIGNMENT                    = 4                                 // isa_defs.h:252:1:
	X_FLOAT_COMPLEX_ALIGNMENT            = 4                                 // isa_defs.h:253:1:
	X_FSTYPSZ                            = 16                                // statvfs.h:46:1:
	X_HAVE_CPUID_INSN                    = 0                                 // isa_defs.h:288:1:
	X_IEEE_754                           = 0                                 // isa_defs.h:246:1:
	X_INT64_TYPE                         = 0                                 // int_types.h:82:1:
	X_INT_ALIGNMENT                      = 4                                 // isa_defs.h:251:1:
	X_IN_ADDR_T                          = 0                                 // byteorder.h:78:1:
	X_IN_PORT_T                          = 0                                 // byteorder.h:73:1:
	X_IPADDR_T                           = 0                                 // in.h:98:1:
	X_ISO_CPP_14882_1998                 = 0                                 // feature_tests.h:466:1:
	X_ISO_C_9899_1999                    = 0                                 // feature_tests.h:472:1:
	X_ISO_C_9899_2011                    = 0                                 // feature_tests.h:478:1:
	X_ISO_TIME_ISO_H                     = 0                                 // time_iso.h:46:1:
	X_LARGEFILE64_SOURCE                 = 1                                 // feature_tests.h:231:1:
	X_LARGEFILE_SOURCE                   = 1                                 // feature_tests.h:235:1:
	X_LITTLE_ENDIAN                      = 0                                 // isa_defs.h:242:1:
	X_LOCALE_T                           = 0                                 // time.h:291:1:
	X_LONGLONG_TYPE                      = 0                                 // feature_tests.h:412:1:
	X_LONG_ALIGNMENT                     = 8                                 // isa_defs.h:254:1:
	X_LONG_DOUBLE_ALIGNMENT              = 16                                // isa_defs.h:258:1:
	X_LONG_DOUBLE_COMPLEX_ALIGNMENT      = 16                                // isa_defs.h:259:1:
	X_LONG_LONG_ALIGNMENT                = 8                                 // isa_defs.h:255:1:
	X_LONG_LONG_ALIGNMENT_32             = 4                                 // isa_defs.h:268:1:
	X_LONG_LONG_LTOH                     = 0                                 // isa_defs.h:244:1:
	X_LP64                               = 1                                 // <predefined>:286:1:
	X_MAX_ALIGNMENT                      = 16                                // isa_defs.h:261:1:
	X_MULTI_DATAMODEL                    = 0                                 // isa_defs.h:279:1:
	X_MUTEX_MAGIC                        = 0x4d58                            // types.h:424:1:
	X_NBBY                               = 8                                 // select.h:100:1:
	X_NETINET_IN_H                       = 0                                 // in.h:33:1:
	X_NET_IF_DL_H                        = 0                                 // if_dl.h:39:1:
	X_NORETURN_KYWD                      = 0                                 // feature_tests.h:448:1:
	X_OFF_T                              = 0                                 // types.h:142:1:
	X_OLD_IPV6_RECVDSTOPTS               = 0x15                              // in.h:1247:1:
	X_PC_2_SYMLINKS                      = 19                                // unistd.h:309:1:
	X_PC_ACCESS_FILTERING                = 25                                // unistd.h:315:1:
	X_PC_ACL_ENABLED                     = 20                                // unistd.h:310:1:
	X_PC_ALLOC_SIZE_MIN                  = 13                                // unistd.h:303:1:
	X_PC_ASYNC_IO                        = 10                                // unistd.h:299:1:
	X_PC_CASE_BEHAVIOR                   = 22                                // unistd.h:312:1:
	X_PC_CHOWN_RESTRICTED                = 9                                 // unistd.h:297:1:
	X_PC_FILESIZEBITS                    = 67                                // unistd.h:325:1:
	X_PC_LAST                            = 101                               // unistd.h:336:1:
	X_PC_LINK_MAX                        = 1                                 // unistd.h:289:1:
	X_PC_MAX_CANON                       = 2                                 // unistd.h:290:1:
	X_PC_MAX_INPUT                       = 3                                 // unistd.h:291:1:
	X_PC_MIN_HOLE_SIZE                   = 21                                // unistd.h:311:1:
	X_PC_NAME_MAX                        = 4                                 // unistd.h:292:1:
	X_PC_NO_TRUNC                        = 7                                 // unistd.h:295:1:
	X_PC_PATH_MAX                        = 5                                 // unistd.h:293:1:
	X_PC_PIPE_BUF                        = 6                                 // unistd.h:294:1:
	X_PC_PRIO_IO                         = 11                                // unistd.h:300:1:
	X_PC_REC_INCR_XFER_SIZE              = 14                                // unistd.h:304:1:
	X_PC_REC_MAX_XFER_SIZE               = 15                                // unistd.h:305:1:
	X_PC_REC_MIN_XFER_SIZE               = 16                                // unistd.h:306:1:
	X_PC_REC_XFER_ALIGN                  = 17                                // unistd.h:307:1:
	X_PC_SATTR_ENABLED                   = 23                                // unistd.h:313:1:
	X_PC_SATTR_EXISTS                    = 24                                // unistd.h:314:1:
	X_PC_SYMLINK_MAX                     = 18                                // unistd.h:308:1:
	X_PC_SYNC_IO                         = 12                                // unistd.h:301:1:
	X_PC_TIMESTAMP_RESOLUTION            = 26                                // unistd.h:317:1:
	X_PC_VDISABLE                        = 8                                 // unistd.h:296:1:
	X_PC_XATTR_ENABLED                   = 100                               // unistd.h:330:1:
	X_PC_XATTR_EXISTS                    = 101                               // unistd.h:331:1:
	X_POINTER_ALIGNMENT                  = 8                                 // isa_defs.h:260:1:
	X_POSIX2_CHAR_TERM                   = 1                                 // unistd.h:391:1:
	X_POSIX2_C_BIND                      = 1                                 // unistd.h:401:1:
	X_POSIX2_C_DEV                       = 1                                 // unistd.h:402:1:
	X_POSIX2_C_VERSION                   = 199209                            // unistd.h:376:1:
	X_POSIX2_FORT_RUN                    = 1                                 // unistd.h:403:1:
	X_POSIX2_LOCALEDEF                   = 1                                 // unistd.h:404:1:
	X_POSIX2_SW_DEV                      = 1                                 // unistd.h:405:1:
	X_POSIX2_UPE                         = 1                                 // unistd.h:406:1:
	X_POSIX2_VERSION                     = 199209                            // unistd.h:363:1:
	X_POSIX_REGEXP                       = 1                                 // unistd.h:410:1:
	X_POSIX_SHELL                        = 1                                 // unistd.h:411:1:
	X_POSIX_VDISABLE                     = 0                                 // param.h:70:1:
	X_POSIX_VERSION                      = 199506                            // unistd.h:355:1:
	X_PSM_MODULES                        = 0                                 // isa_defs.h:284:1:
	X_PTRDIFF_T                          = 0                                 // types.h:112:1:
	X_RESTRICT_KYWD                      = 0                                 // feature_tests.h:435:1:
	X_RTC_CONFIG                         = 0                                 // isa_defs.h:285:1:
	X_RUSAGESYS_GETRUSAGE                = 0                                 // resource.h:191:1:
	X_RUSAGESYS_GETRUSAGE_CHLD           = 1                                 // resource.h:192:1:
	X_RUSAGESYS_GETRUSAGE_LWP            = 2                                 // resource.h:193:1:
	X_RUSAGESYS_GETVMUSAGE               = 3                                 // resource.h:194:1:
	X_RWL_MAGIC                          = 0x5257                            // types.h:427:1:
	X_SA_FAMILY_T                        = 0                                 // socket_impl.h:42:1:
	X_SC_2_CHAR_TERM                     = 66                                // unistd.h:175:1:
	X_SC_2_C_BIND                        = 45                                // unistd.h:153:1:
	X_SC_2_C_DEV                         = 46                                // unistd.h:154:1:
	X_SC_2_C_VERSION                     = 47                                // unistd.h:155:1:
	X_SC_2_FORT_DEV                      = 48                                // unistd.h:156:1:
	X_SC_2_FORT_RUN                      = 49                                // unistd.h:157:1:
	X_SC_2_LOCALEDEF                     = 50                                // unistd.h:158:1:
	X_SC_2_PBS                           = 724                               // unistd.h:246:1:
	X_SC_2_PBS_ACCOUNTING                = 725                               // unistd.h:247:1:
	X_SC_2_PBS_CHECKPOINT                = 726                               // unistd.h:248:1:
	X_SC_2_PBS_LOCATE                    = 728                               // unistd.h:249:1:
	X_SC_2_PBS_MESSAGE                   = 729                               // unistd.h:250:1:
	X_SC_2_PBS_TRACK                     = 730                               // unistd.h:251:1:
	X_SC_2_SW_DEV                        = 51                                // unistd.h:159:1:
	X_SC_2_UPE                           = 52                                // unistd.h:160:1:
	X_SC_2_VERSION                       = 53                                // unistd.h:161:1:
	X_SC_ADVISORY_INFO                   = 731                               // unistd.h:252:1:
	X_SC_AIO_LISTIO_MAX                  = 18                                // unistd.h:125:1:
	X_SC_AIO_MAX                         = 19                                // unistd.h:126:1:
	X_SC_AIO_PRIO_DELTA_MAX              = 20                                // unistd.h:127:1:
	X_SC_ARG_MAX                         = 1                                 // unistd.h:106:1:
	X_SC_ASYNCHRONOUS_IO                 = 21                                // unistd.h:128:1:
	X_SC_ATEXIT_MAX                      = 76                                // unistd.h:179:1:
	X_SC_AVPHYS_PAGES                    = 501                               // unistd.h:190:1:
	X_SC_BARRIERS                        = 732                               // unistd.h:253:1:
	X_SC_BC_BASE_MAX                     = 54                                // unistd.h:162:1:
	X_SC_BC_DIM_MAX                      = 55                                // unistd.h:163:1:
	X_SC_BC_SCALE_MAX                    = 56                                // unistd.h:164:1:
	X_SC_BC_STRING_MAX                   = 57                                // unistd.h:165:1:
	X_SC_CHILD_MAX                       = 2                                 // unistd.h:107:1:
	X_SC_CLK_TCK                         = 3                                 // unistd.h:108:1:
	X_SC_CLOCK_SELECTION                 = 733                               // unistd.h:254:1:
	X_SC_COHER_BLKSZ                     = 503                               // unistd.h:196:1:
	X_SC_COLL_WEIGHTS_MAX                = 58                                // unistd.h:166:1:
	X_SC_CPUID_MAX                       = 517                               // unistd.h:211:1:
	X_SC_CPUTIME                         = 734                               // unistd.h:255:1:
	X_SC_DCACHE_ASSOC                    = 513                               // unistd.h:206:1:
	X_SC_DCACHE_BLKSZ                    = 510                               // unistd.h:203:1:
	X_SC_DCACHE_LINESZ                   = 508                               // unistd.h:201:1:
	X_SC_DCACHE_SZ                       = 506                               // unistd.h:199:1:
	X_SC_DCACHE_TBLKSZ                   = 511                               // unistd.h:204:1:
	X_SC_DELAYTIMER_MAX                  = 22                                // unistd.h:129:1:
	X_SC_EPHID_MAX                       = 518                               // unistd.h:212:1:
	X_SC_EXPR_NEST_MAX                   = 59                                // unistd.h:167:1:
	X_SC_FSYNC                           = 23                                // unistd.h:130:1:
	X_SC_GETGR_R_SIZE_MAX                = 569                               // unistd.h:220:1:
	X_SC_GETPW_R_SIZE_MAX                = 570                               // unistd.h:221:1:
	X_SC_HOST_NAME_MAX                   = 735                               // unistd.h:256:1:
	X_SC_ICACHE_ASSOC                    = 512                               // unistd.h:205:1:
	X_SC_ICACHE_BLKSZ                    = 509                               // unistd.h:202:1:
	X_SC_ICACHE_LINESZ                   = 507                               // unistd.h:200:1:
	X_SC_ICACHE_SZ                       = 505                               // unistd.h:198:1:
	X_SC_IOV_MAX                         = 77                                // unistd.h:180:1:
	X_SC_IPV6                            = 762                               // unistd.h:283:1:
	X_SC_JOB_CONTROL                     = 6                                 // unistd.h:111:1:
	X_SC_LINE_MAX                        = 60                                // unistd.h:168:1:
	X_SC_LOGIN_NAME_MAX                  = 571                               // unistd.h:222:1:
	X_SC_LOGNAME_MAX                     = 10                                // unistd.h:116:1:
	X_SC_MAPPED_FILES                    = 24                                // unistd.h:131:1:
	X_SC_MAXPID                          = 514                               // unistd.h:208:1:
	X_SC_MEMLOCK                         = 25                                // unistd.h:132:1:
	X_SC_MEMLOCK_RANGE                   = 26                                // unistd.h:133:1:
	X_SC_MEMORY_PROTECTION               = 27                                // unistd.h:134:1:
	X_SC_MESSAGE_PASSING                 = 28                                // unistd.h:135:1:
	X_SC_MONOTONIC_CLOCK                 = 736                               // unistd.h:257:1:
	X_SC_MQ_OPEN_MAX                     = 29                                // unistd.h:136:1:
	X_SC_MQ_PRIO_MAX                     = 30                                // unistd.h:137:1:
	X_SC_NGROUPS_MAX                     = 4                                 // unistd.h:109:1:
	X_SC_NPROCESSORS_CONF                = 14                                // unistd.h:120:1:
	X_SC_NPROCESSORS_MAX                 = 516                               // unistd.h:210:1:
	X_SC_NPROCESSORS_ONLN                = 15                                // unistd.h:121:1:
	X_SC_OPEN_MAX                        = 5                                 // unistd.h:110:1:
	X_SC_PAGESIZE                        = 11                                // unistd.h:117:1:
	X_SC_PAGE_SIZE                       = 11                                // unistd.h:182:1:
	X_SC_PASS_MAX                        = 9                                 // unistd.h:115:1:
	X_SC_PHYS_PAGES                      = 500                               // unistd.h:189:1:
	X_SC_PRIORITIZED_IO                  = 31                                // unistd.h:138:1:
	X_SC_PRIORITY_SCHEDULING             = 32                                // unistd.h:139:1:
	X_SC_RAW_SOCKETS                     = 763                               // unistd.h:284:1:
	X_SC_READER_WRITER_LOCKS             = 737                               // unistd.h:258:1:
	X_SC_REALTIME_SIGNALS                = 33                                // unistd.h:140:1:
	X_SC_REGEXP                          = 738                               // unistd.h:259:1:
	X_SC_RE_DUP_MAX                      = 61                                // unistd.h:169:1:
	X_SC_RTSIG_MAX                       = 34                                // unistd.h:141:1:
	X_SC_SAVED_IDS                       = 7                                 // unistd.h:112:1:
	X_SC_SEMAPHORES                      = 35                                // unistd.h:142:1:
	X_SC_SEM_NSEMS_MAX                   = 36                                // unistd.h:143:1:
	X_SC_SEM_VALUE_MAX                   = 37                                // unistd.h:144:1:
	X_SC_SHARED_MEMORY_OBJECTS           = 38                                // unistd.h:145:1:
	X_SC_SHELL                           = 739                               // unistd.h:260:1:
	X_SC_SIGQUEUE_MAX                    = 39                                // unistd.h:146:1:
	X_SC_SIGRT_MAX                       = 41                                // unistd.h:148:1:
	X_SC_SIGRT_MIN                       = 40                                // unistd.h:147:1:
	X_SC_SPAWN                           = 740                               // unistd.h:261:1:
	X_SC_SPIN_LOCKS                      = 741                               // unistd.h:262:1:
	X_SC_SPLIT_CACHE                     = 504                               // unistd.h:197:1:
	X_SC_SPORADIC_SERVER                 = 742                               // unistd.h:263:1:
	X_SC_SS_REPL_MAX                     = 743                               // unistd.h:264:1:
	X_SC_STACK_PROT                      = 515                               // unistd.h:209:1:
	X_SC_STREAM_MAX                      = 16                                // unistd.h:122:1:
	X_SC_SYMLOOP_MAX                     = 744                               // unistd.h:265:1:
	X_SC_SYNCHRONIZED_IO                 = 42                                // unistd.h:149:1:
	X_SC_THREADS                         = 576                               // unistd.h:227:1:
	X_SC_THREAD_ATTR_STACKADDR           = 577                               // unistd.h:228:1:
	X_SC_THREAD_ATTR_STACKSIZE           = 578                               // unistd.h:229:1:
	X_SC_THREAD_CPUTIME                  = 745                               // unistd.h:266:1:
	X_SC_THREAD_DESTRUCTOR_ITERATIONS    = 568                               // unistd.h:219:1:
	X_SC_THREAD_KEYS_MAX                 = 572                               // unistd.h:223:1:
	X_SC_THREAD_PRIORITY_SCHEDULING      = 579                               // unistd.h:230:1:
	X_SC_THREAD_PRIO_INHERIT             = 580                               // unistd.h:231:1:
	X_SC_THREAD_PRIO_PROTECT             = 581                               // unistd.h:232:1:
	X_SC_THREAD_PROCESS_SHARED           = 582                               // unistd.h:233:1:
	X_SC_THREAD_SAFE_FUNCTIONS           = 583                               // unistd.h:234:1:
	X_SC_THREAD_SPORADIC_SERVER          = 746                               // unistd.h:267:1:
	X_SC_THREAD_STACK_MIN                = 573                               // unistd.h:224:1:
	X_SC_THREAD_THREADS_MAX              = 574                               // unistd.h:225:1:
	X_SC_TIMEOUTS                        = 747                               // unistd.h:268:1:
	X_SC_TIMERS                          = 43                                // unistd.h:150:1:
	X_SC_TIMER_MAX                       = 44                                // unistd.h:151:1:
	X_SC_TRACE                           = 748                               // unistd.h:269:1:
	X_SC_TRACE_EVENT_FILTER              = 749                               // unistd.h:270:1:
	X_SC_TRACE_EVENT_NAME_MAX            = 750                               // unistd.h:271:1:
	X_SC_TRACE_INHERIT                   = 751                               // unistd.h:272:1:
	X_SC_TRACE_LOG                       = 752                               // unistd.h:273:1:
	X_SC_TRACE_NAME_MAX                  = 753                               // unistd.h:274:1:
	X_SC_TRACE_SYS_MAX                   = 754                               // unistd.h:275:1:
	X_SC_TRACE_USER_EVENT_MAX            = 755                               // unistd.h:276:1:
	X_SC_TTY_NAME_MAX                    = 575                               // unistd.h:226:1:
	X_SC_TYPED_MEMORY_OBJECTS            = 756                               // unistd.h:277:1:
	X_SC_TZNAME_MAX                      = 17                                // unistd.h:123:1:
	X_SC_T_IOV_MAX                       = 79                                // unistd.h:186:1:
	X_SC_UADDR_MAX                       = 519                               // unistd.h:213:1:
	X_SC_V6_ILP32_OFF32                  = 757                               // unistd.h:278:1:
	X_SC_V6_ILP32_OFFBIG                 = 758                               // unistd.h:279:1:
	X_SC_V6_LP64_OFF64                   = 759                               // unistd.h:280:1:
	X_SC_V6_LPBIG_OFFBIG                 = 760                               // unistd.h:281:1:
	X_SC_VERSION                         = 8                                 // unistd.h:113:1:
	X_SC_XBS5_ILP32_OFF32                = 720                               // unistd.h:240:1:
	X_SC_XBS5_ILP32_OFFBIG               = 721                               // unistd.h:241:1:
	X_SC_XBS5_LP64_OFF64                 = 722                               // unistd.h:242:1:
	X_SC_XBS5_LPBIG_OFFBIG               = 723                               // unistd.h:243:1:
	X_SC_XOPEN_CRYPT                     = 62                                // unistd.h:170:1:
	X_SC_XOPEN_ENH_I18N                  = 63                                // unistd.h:171:1:
	X_SC_XOPEN_LEGACY                    = 717                               // unistd.h:237:1:
	X_SC_XOPEN_REALTIME                  = 718                               // unistd.h:238:1:
	X_SC_XOPEN_REALTIME_THREADS          = 719                               // unistd.h:239:1:
	X_SC_XOPEN_SHM                       = 64                                // unistd.h:172:1:
	X_SC_XOPEN_STREAMS                   = 761                               // unistd.h:282:1:
	X_SC_XOPEN_UNIX                      = 78                                // unistd.h:181:1:
	X_SC_XOPEN_VERSION                   = 12                                // unistd.h:118:1:
	X_SC_XOPEN_XCU_VERSION               = 67                                // unistd.h:176:1:
	X_SEMA_MAGIC                         = 0x534d                            // types.h:425:1:
	X_SHORT_ALIGNMENT                    = 2                                 // isa_defs.h:250:1:
	X_SIGEVENT                           = 0                                 // time.h:132:1:
	X_SIGSET_T                           = 0                                 // select.h:73:1:
	X_SIGVAL                             = 0                                 // time.h:124:1:
	X_SIZE_T                             = 0                                 // types.h:540:1:
	X_SOCKLEN_T                          = 0                                 // in.h:48:1:
	X_SOFT_HOSTID                        = 0                                 // isa_defs.h:286:1:
	X_SSIZE_T                            = 0                                 // types.h:549:1:
	X_SS_MAXSIZE                         = 256                               // socket_impl.h:70:1:
	X_STACK_GROWS_DOWNWARD               = 0                                 // isa_defs.h:243:1:
	X_STDC_C11                           = 0                                 // feature_tests.h:165:1:
	X_STDC_C99                           = 0                                 // feature_tests.h:169:1:
	X_SUNOS_VTOC_16                      = 0                                 // isa_defs.h:280:1:
	X_SUSECONDS_T                        = 0                                 // types.h:343:1:
	X_SYS_BYTEORDER_H                    = 0                                 // byteorder.h:41:1:
	X_SYS_CCOMPILE_H                     = 0                                 // ccompile.h:32:1:
	X_SYS_CONDVAR_H                      = 0                                 // condvar.h:39:1:
	X_SYS_CRED_H                         = 0                                 // cred.h:35:1:
	X_SYS_FEATURE_TESTS_H                = 0                                 // feature_tests.h:41:1:
	X_SYS_INT_TYPES_H                    = 0                                 // int_types.h:30:1:
	X_SYS_ISA_DEFS_H                     = 0                                 // isa_defs.h:30:1:
	X_SYS_KMEM_H                         = 0                                 // kmem.h:33:1:
	X_SYS_KSTAT_H                        = 0                                 // kstat.h:29:1:
	X_SYS_KSYNCH_H                       = 0                                 // ksynch.h:31:1:
	X_SYS_LIST_H                         = 0                                 // list.h:27:1:
	X_SYS_LIST_IMPL_H                    = 0                                 // list_impl.h:28:1:
	X_SYS_MACHLOCK_H                     = 0                                 // machlock.h:28:1:
	X_SYS_MACHTYPES_H                    = 0                                 // machtypes.h:27:1:
	X_SYS_MUTEX_H                        = 0                                 // mutex.h:26:1:
	X_SYS_NULL_H                         = 0                                 // null.h:17:1:
	X_SYS_PARAM_H                        = 0                                 // param.h:41:1:
	X_SYS_REFSTR_H                       = 0                                 // refstr.h:30:1:
	X_SYS_RESOURCE_H                     = 0                                 // resource.h:43:1:
	X_SYS_RWLOCK_H                       = 0                                 // rwlock.h:31:1:
	X_SYS_RWSTLOCK_H                     = 0                                 // rwstlock.h:28:1:
	X_SYS_SELECT_H                       = 0                                 // select.h:45:1:
	X_SYS_SEMAPHORE_H                    = 0                                 // semaphore.h:28:1:
	X_SYS_SOCKET_IMPL_H                  = 0                                 // socket_impl.h:35:1:
	X_SYS_STATVFS_H                      = 0                                 // statvfs.h:33:1:
	X_SYS_TIME_H                         = 0                                 // time.h:27:1:
	X_SYS_TIME_IMPL_H                    = 0                                 // time_impl.h:38:1:
	X_SYS_TSOL_LABEL_H                   = 0                                 // label.h:27:1:
	X_SYS_TYPES_H                        = 0                                 // types.h:35:1:
	X_SYS_T_LOCK_H                       = 0                                 // t_lock.h:34:1:
	X_SYS_UADMIN_H                       = 0                                 // uadmin.h:33:1:
	X_SYS_UIO_H                          = 0                                 // uio.h:45:1:
	X_SYS_UNISTD_H                       = 0                                 // unistd.h:40:1:
	X_SYS_UN_H                           = 0                                 // un.h:39:1:
	X_SYS_VFS_H                          = 0                                 // vfs.h:38:1:
	X_SYS_VMEM_H                         = 0                                 // vmem.h:27:1:
	X_SYS_VNODE_H                        = 0                                 // vnode.h:43:1:
	X_SYS_ZONE_H                         = 0                                 // zone.h:30:1:
	X_TIMER_T                            = 0                                 // types.h:573:1:
	X_TIME_H                             = 0                                 // time.h:37:1:
	X_TIME_T                             = 0                                 // types.h:558:1:
	X_TTY_BUFSIZ                         = 2048                              // param.h:75:1:
	X_UID_T                              = 0                                 // types.h:400:1:
	X_VM_SEG_ENUM_H                      = 0                                 // seg_enum.h:34:1:
	X_XOPEN_ENH_I18N                     = 1                                 // unistd.h:389:1:
	X_XOPEN_REALTIME                     = 1                                 // unistd.h:388:1:
	X_XOPEN_SHM                          = 1                                 // unistd.h:390:1:
	X_XOPEN_STREAMS                      = 1                                 // unistd.h:412:1:
	X_XOPEN_UNIX                         = 0                                 // unistd.h:382:1:
	X_XOPEN_VERSION                      = 3                                 // feature_tests.h:392:1:
	X_XOPEN_XCU_VERSION                  = 4                                 // unistd.h:385:1:
	X_XOPEN_XPG3                         = 0                                 // unistd.h:380:1:
	X_XOPEN_XPG4                         = 0                                 // unistd.h:381:1:
	Sun                                  = 1                                 // <predefined>:172:1:
	Unix                                 = 1                                 // <predefined>:175:1:
)

const ( /* condvar.h:63:1: */
	CV_DEFAULT = 0
	CV_DRIVER  = 1
)

// Client response to kmem move callback
const ( /* kmem.h:92:1: */
	KMEM_CBRC_YES       = 0
	KMEM_CBRC_NO        = 1
	KMEM_CBRC_LATER     = 2
	KMEM_CBRC_DONT_NEED = 3
	KMEM_CBRC_DONT_KNOW = 4
)

// The definitions of the symbolic interrupt levels:
//
//   CLOCK_LEVEL =>  The level at which one must be to block the clock.
//
//   LOCK_LEVEL  =>  The highest level at which one may block (and thus the
//                   highest level at which one may acquire adaptive locks)
//                   Also the highest level at which one may be preempted.
//
//   DISP_LEVEL  =>  The level at which one must be to perform dispatcher
//                   operations.
//
// The constraints on the platform:
//
//  - CLOCK_LEVEL must be less than or equal to LOCK_LEVEL
//  - LOCK_LEVEL must be less than DISP_LEVEL
//  - DISP_LEVEL should be as close to LOCK_LEVEL as possible
//
// Note that LOCK_LEVEL and CLOCK_LEVEL have historically always been equal;
// changing this relationship is probably possible but not advised.
//

// The following mask is for the cpu_intr_actv bits corresponding to
// high-level PILs. It should equal:
// ((((1 << PIL_MAX + 1) - 1) >> LOCK_LEVEL + 1) << LOCK_LEVEL + 1)

// The semaphore code depends on being able to represent a lock plus
// owner in a single 32-bit word.  (Mutexes used to have a similar
// dependency, but no longer.)  Thus the owner must contain at most
// 24 significant bits.  At present only threads and semaphores
// must be aware of this vile constraint.  Different ISAs may handle this
// differently depending on their capabilities (e.g. compare-and-swap)
// and limitations (e.g. constraints on alignment and/or KERNELBASE).

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
// Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// Public interface to mutual exclusion locks.  See mutex(9F) for details.
//
// The basic mutex type is MUTEX_ADAPTIVE, which is expected to be used
// in almost all of the kernel.  MUTEX_SPIN provides interrupt blocking
// and must be used in interrupt handlers above LOCK_LEVEL.  The iblock
// cookie argument to mutex_init() encodes the interrupt level to block.
// The iblock cookie must be NULL for adaptive locks.
//
// MUTEX_DEFAULT is the type usually specified (except in drivers) to
// mutex_init().  It is identical to MUTEX_ADAPTIVE.
//
// MUTEX_DRIVER is always used by drivers.  mutex_init() converts this to
// either MUTEX_ADAPTIVE or MUTEX_SPIN depending on the iblock cookie.
//
// Mutex statistics can be gathered on the fly, without rebooting or
// recompiling the kernel, via the lockstat driver (lockstat(4D)).
const ( /* mutex.h:56:1: */
	MUTEX_ADAPTIVE = 0 // spin if owner is running, otherwise block
	MUTEX_SPIN     = 1 // block interrupts and spin
	MUTEX_DRIVER   = 4 // driver (DDI) mutex
	MUTEX_DEFAULT  = 6
)

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Copyright (c) 2013, Joyent, Inc.  All rights reserved.

// Public interface to readers/writer locks.  See rwlock(9F) for details.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

const ( /* rwlock.h:45:1: */
	RW_DRIVER  = 2 // driver (DDI) rwlock
	RW_DEFAULT = 4
)

const ( /* rwlock.h:50:1: */
	RW_WRITER              = 0
	RW_READER              = 1
	RW_READER_STARVEWRITER = 2
)

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1993-1998 by Sun Microsystems, Inc.
// All rights reserved.

// Public interface to semaphores.  See semaphore(9F) for details.

const ( /* semaphore.h:44:1: */
	SEMA_DEFAULT = 0
	SEMA_DRIVER  = 1
) // used for block sizes

// The boolean_t type has had a varied amount of exposure over the years in
// terms of how its enumeration constants have been exposed. In particular, it
// originally used the __XOPEN_OR_POSIX macro to determine whether to prefix the
// B_TRUE and B_FALSE with an underscore. This check never included the
// question of if we were in a strict ANSI C environment or whether extensions
// were defined.
//
// Compilers such as clang started defaulting to always including an
// XOPEN_SOURCE declaration on behalf of users, but also noted __EXTENSIONS__.
// This would lead most software that had used the non-underscore versions to
// need it. As such, we have adjusted the non-strict XOPEN environment to retain
// its old behavior so as to minimize namespace pollution; however, we instead
// include both variants of the definitions in the generally visible version
// allowing software written in either world to hopefully end up in a good
// place.
//
// This isn't perfect, but should hopefully minimize the pain for folks actually
// trying to build software.
const ( /* types.h:215:1: */
	B_FALSE   = 0
	B_TRUE    = 1
	X_B_FALSE = 0
	X_B_TRUE  = 1
)

// uio extensions
//
// PSARC 2009/478: Copy Reduction Interfaces
const ( /* uio.h:146:1: */
	UIOTYPE_ASYNCIO  = 0
	UIOTYPE_ZEROCOPY = 1
	UIOTYPE_PEEKSIZE = 2
)

// I/O direction.
const ( /* uio.h:220:1: */
	UIO_READ  = 0
	UIO_WRITE = 1
)

// Segment flag values.
const ( /* uio.h:93:1: */
	UIO_USERSPACE  = 0
	UIO_SYSSPACE   = 1
	UIO_USERISPACE = 2
)

// Reasons for calling the vfs_mountroot() operation.
const ( /* vfs.h:306:1: */
	ROOT_INIT    = 0
	ROOT_REMOUNT = 1
	ROOT_UNMOUNT = 2
)

// Reasons for calling the VFS_VNSTATE():
const ( /* vfs.h:312:1: */
	VNTRANS_EXISTS    = 0
	VNTRANS_IDLED     = 1
	VNTRANS_RECLAIMED = 2
	VNTRANS_DESTROYED = 3
)

const ( /* vfs.h:403:1: */
	VFSDEF_VERSION = 5
)

// The vnode is the focus of all file activity in UNIX.
// A vnode is allocated for each active file, each current
// directory, each mounted-on file, and the root.
//
// Each vnode is usually associated with a file-system-specific node (for
// UFS, this is the in-memory inode).  Generally, a vnode and an fs-node
// should be created and destroyed together as a pair.
//
// If a vnode is reused for a new file, it should be reinitialized by calling
// either vn_reinit() or vn_recycle().
//
// vn_reinit() resets the entire vnode as if it was returned by vn_alloc().
// The caller is responsible for setting up the entire vnode after calling
// vn_reinit().  This is important when using kmem caching where the vnode is
// allocated by a constructor, for instance.
//
// vn_recycle() is used when the file system keeps some state around in both
// the vnode and the associated FS-node.  In UFS, for example, the inode of
// a deleted file can be reused immediately.  The v_data, v_vfsp, v_op, etc.
// remains the same but certain fields related to the previous instance need
// to be reset.  In particular:
//	v_femhead
//	v_path
//	v_rdcnt, v_wrcnt
//	v_mmap_read, v_mmap_write

// vnode types.  VNON means no type.  These values are unrelated to
// values in on-disk inodes.
const ( /* vnode.h:161:1: */
	VNON  = 0
	VREG  = 1
	VDIR  = 2
	VBLK  = 3
	VCHR  = 4
	VLNK  = 5
	VFIFO = 6
	VDOOR = 7
	VPROC = 8
	VSOCK = 9
	VPORT = 10
	VBAD  = 11
)

// Attributes of interest to the caller of setattr or getattr.
/*			0x04000 */ // unused
// If AT_XVATTR is set then there are additional bits to process in
// the xvattr_t's attribute bitmap.  If this is not set then the bitmap
// MUST be ignored.  Note that this bit must be set/cleared explicitly.
// That is, setting AT_ALL will NOT set AT_XVATTR.

// Attribute bits used in the extensible attribute's (xva's) attribute
// bitmaps.  Note that the bitmaps are made up of a variable length number
// of 32-bit words.  The convention is to use XAT{n}_{attrname} where "n"
// is the element in the bitmap (starting at 1).  This convention is for
// the convenience of the maintainer to keep track of which element each
// attribute belongs to.
//
// NOTE THAT CONSUMERS MUST *NOT* USE THE XATn_* DEFINES DIRECTLY.  CONSUMERS
// MUST USE THE XAT_* DEFINES.

// Support for XAT_* optional attributes

// Used to pry out the index and attribute bits from the XAT_* attributes
// defined below.  Note that we're masking things down to 32 bits then
// casting to uint32_t.

// The following defines present a "flat namespace" so that consumers don't
// need to keep track of which element belongs to which bitmap entry.
//
// NOTE THAT THESE MUST NEVER BE OR-ed TOGETHER

// The returned attribute map array (xva_rtnattrmap[]) is located past the
// requested attribute map array (xva_reqattrmap[]).  Its location changes
// when the array sizes change.  We use a separate pointer in a known location
// (xva_rtnattrmapp) to hold the location of xva_rtnattrmap[].  This is
// set in xva_init()

// XVA_SET_REQ() sets an attribute bit in the proper element in the bitmap
// of requested attributes (xva_reqattrmap[]).
// XVA_CLR_REQ() clears an attribute bit in the proper element in the bitmap
// of requested attributes (xva_reqattrmap[]).

// XVA_SET_RTN() sets an attribute bit in the proper element in the bitmap
// of returned attributes (xva_rtnattrmap[]).

// XVA_ISSET_REQ() checks the requested attribute bitmap (xva_reqattrmap[])
// to see of the corresponding attribute bit is set.  If so, returns non-zero.

// XVA_ISSET_RTN() checks the returned attribute bitmap (xva_rtnattrmap[])
// to see of the corresponding attribute bit is set.  If so, returns non-zero.

//  Modes.  Some values same as S_xxx entries from stat.h for convenience.

// Permissions.

// VOP_ACCESS flags

// Check whether mandatory file locking is enabled.

// Flags for vnode operations.
const ( /* vnode.h:795:1: */
	RMFILE      = 0
	RMDIRECTORY = 1
)       // rm or rmdir (remove)
const ( /* vnode.h:796:1: */
	NO_FOLLOW = 0
	FOLLOW    = 1
)       // follow symlinks (or not)
const ( /* vnode.h:797:1: */
	NONEXCL = 0
	EXCL    = 1
)       // (non)excl create
const ( /* vnode.h:798:1: */
	CRCREAT = 0
	CRMKNOD = 1
	CRMKDIR = 2
)

// Vnode Events - Used by VOP_VNEVENT
// The VE_PRE_RENAME_* events fire before the rename operation and are
// primarily used for specialized applications, such as NFSv4 delegation, which
// need to know about rename before it occurs.
const ( /* vnode.h:811:1: */
	VE_SUPPORT             = 0  // Query
	VE_RENAME_SRC          = 1  // Rename, with vnode as source
	VE_RENAME_DEST         = 2  // Rename, with vnode as target/destination
	VE_REMOVE              = 3  // Remove of vnode's name
	VE_RMDIR               = 4  // Remove of directory vnode's name
	VE_CREATE              = 5  // Create with vnode's name which exists
	VE_LINK                = 6  // Link with vnode's name as source
	VE_RENAME_DEST_DIR     = 7  // Rename with vnode as target dir
	VE_MOUNTEDOVER         = 8  // File or Filesystem got mounted over vnode
	VE_TRUNCATE            = 9  // Truncate
	VE_PRE_RENAME_SRC      = 10 // Pre-rename, with vnode as source
	VE_PRE_RENAME_DEST     = 11 // Pre-rename, with vnode as target/dest.
	VE_PRE_RENAME_DEST_DIR = 12 // Pre-rename with vnode as target dir
	VE_RENAME_SRC_DIR      = 13 // Rename with vnode as source dir
	VE_RESIZE              = 14
)

// Values for checking vnode open and map counts
const ( /* vnode.h:832:1: */
	V_READ    = 0
	V_WRITE   = 1
	V_RDORWR  = 2
	V_RDANDWR = 3
)

// extended error information

// zone_status values
//
// You must modify zone_status_names in mdb(1)'s genunix module
// (genunix/zone.c) when you modify this enum.
const ( /* zone.h:259:1: */
	ZONE_IS_UNINITIALIZED = 0
	ZONE_IS_INITIALIZED   = 1
	ZONE_IS_READY         = 2
	ZONE_IS_BOOTING       = 3
	ZONE_IS_RUNNING       = 4
	ZONE_IS_SHUTTING_DOWN = 5
	ZONE_IS_EMPTY         = 6
	ZONE_IS_DOWN          = 7
	ZONE_IS_DYING         = 8
	ZONE_IS_DEAD          = 9
)

// Valid commands which may be issued by zoneadm to zoneadmd.  The kernel also
// communicates with zoneadmd, but only uses Z_REBOOT and Z_HALT.
const ( /* zone.h:278:1: */
	Z_READY             = 0
	Z_BOOT              = 1
	Z_FORCEBOOT         = 2
	Z_REBOOT            = 3
	Z_HALT              = 4
	Z_NOTE_UNINSTALLING = 5
	Z_MOUNT             = 6
	Z_FORCEMOUNT        = 7
	Z_UNMOUNT           = 8
	Z_SHUTDOWN          = 9
)

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Portions of this source code were derived from Berkeley 4.3 BSD
// under license from the Regents of the University of California.

// These enumerations are needed in both <vm/seg.h> and
// <sys/vnode.h> in order to declare function prototypes.

// Fault information passed to the seg fault handling routine.
// The F_SOFTLOCK and F_SOFTUNLOCK are used by software
// to lock and unlock pages for physical I/O.
const ( /* seg_enum.h:50:1: */
	F_INVAL      = 0 // invalid page
	F_PROT       = 1 // protection fault
	F_SOFTLOCK   = 2 // software requested locking
	F_SOFTUNLOCK = 3
)

// Lock information passed to the seg pagelock handling routine.
const ( /* seg_enum.h:60:1: */
	L_PAGELOCK   = 0 // lock pages
	L_PAGEUNLOCK = 1
)

// seg_rw gives the access type for a fault operation
const ( /* seg_enum.h:68:1: */
	S_OTHER      = 0 // unknown or not touched
	S_READ       = 1 // read access attempted
	S_WRITE      = 2 // write access attempted
	S_EXEC       = 3 // execution access attempted
	S_CREATE     = 4 // create if page doesn't exist
	S_READ_NOCOW = 5
)

// Capabilities for capability segment op.
const ( /* seg_enum.h:80:1: */
	S_CAPABILITY_NOMINFLT = 0
)

type Ptrdiff_t = int64 /* <builtin>:3:26 */

type Size_t = uint64 /* <builtin>:9:23 */

type Wchar_t = int32 /* <builtin>:15:24 */

type X__int128_t = struct {
	Flo int64
	Fhi int64
} /* <builtin>:21:43 */ // must match github.com/opentoys/sqlite/mathutil.Int128
type X__uint128_t = struct {
	Flo uint64
	Fhi uint64
} /* <builtin>:22:44 */ // must match github.com/opentoys/sqlite/mathutil.Int128

type X__builtin_va_list = uintptr /* <builtin>:46:14 */
type X__float128 = float64        /* <builtin>:47:21 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
// Copyright 2016 Toomas Soome <tsoome@me.com>
// Copyright (c) 2016, 2017 by Delphix. All rights reserved.
// Copyright 2016 Nexenta Systems, Inc.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Portions of this source code were derived from Berkeley 4.3 BSD
// under license from the Regents of the University of California.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
// Copyright 2014 Igor Kozhukhov <ikozhukhov@gmail.com>.
// Copyright 2019 Nexenta Systems, Inc. All rights reserved.
// Copyright 2020 Joyent, Inc.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2015 EveryCity Ltd. All rights reserved.
// Copyright 2019 Joyent, Inc.

// This file contains definitions designed to enable different compilers
// to be used harmoniously on Solaris systems.

// Allow for version tests for compiler bugs and features.

// analogous to lint's PRINTFLIKEn

// Handle the kernel printf routines that can take '%b' too

// This one's pretty obvious -- the function never returns

// The function is 'extern inline' and expects GNU C89 behaviour, not C99
// behaviour.
//
// Should only be used on 'extern inline' definitions for GCC.

// The function has control flow such that it may return multiple times (in
// the manner of setjmp or vfork)

// This is an appropriate label for functions that do not
// modify their arguments, e.g. strlen()

// This is a stronger form of __pure__. Can be used for functions
// that do not modify their arguments and don't depend on global
// memory.

// This attribute, attached to a variable, means that the variable is meant to
// be possibly unused. GCC will not produce a warning for this variable.

// Shorthand versions for readability

// In release build, disable warnings about variables
// which are used only for debugging.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2016 Joyent, Inc.

// This header file serves to group a set of well known defines and to
// set these for each instruction set architecture.  These defines may
// be divided into two groups;  characteristics of the processor and
// implementation choices for Solaris on a processor.
//
// Processor Characteristics:
//
// _LITTLE_ENDIAN / _BIG_ENDIAN:
//	The natural byte order of the processor.  A pointer to an int points
//	to the least/most significant byte of that int.
//
// _STACK_GROWS_UPWARD / _STACK_GROWS_DOWNWARD:
//	The processor specific direction of stack growth.  A push onto the
//	stack increases/decreases the stack pointer, so it stores data at
//	successively higher/lower addresses.  (Stackless machines ignored
//	without regrets).
//
// _LONG_LONG_HTOL / _LONG_LONG_LTOH:
//	A pointer to a long long points to the most/least significant long
//	within that long long.
//
// _BIT_FIELDS_HTOL / _BIT_FIELDS_LTOH:
//	The C compiler assigns bit fields from the high/low to the low/high end
//	of an int (most to least significant vs. least to most significant).
//
// _IEEE_754:
//	The processor (or supported implementations of the processor)
//	supports the ieee-754 floating point standard.  No other floating
//	point standards are supported (or significant).  Any other supported
//	floating point formats are expected to be cased on the ISA processor
//	symbol.
//
// _CHAR_IS_UNSIGNED / _CHAR_IS_SIGNED:
//	The C Compiler implements objects of type `char' as `unsigned' or
//	`signed' respectively.  This is really an implementation choice of
//	the compiler writer, but it is specified in the ABI and tends to
//	be uniform across compilers for an instruction set architecture.
//	Hence, it has the properties of a processor characteristic.
//
// _CHAR_ALIGNMENT / _SHORT_ALIGNMENT / _INT_ALIGNMENT / _LONG_ALIGNMENT /
// _LONG_LONG_ALIGNMENT / _DOUBLE_ALIGNMENT / _LONG_DOUBLE_ALIGNMENT /
// _POINTER_ALIGNMENT / _FLOAT_ALIGNMENT:
//	The ABI defines alignment requirements of each of the primitive
//	object types.  Some, if not all, may be hardware requirements as
// 	well.  The values are expressed in "byte-alignment" units.
//
// _MAX_ALIGNMENT:
//	The most stringent alignment requirement as specified by the ABI.
//	Equal to the maximum of all the above _XXX_ALIGNMENT values.
//
// _MAX_ALIGNMENT_TYPE:
// 	The name of the C type that has the value descried in _MAX_ALIGNMENT.
//
// _ALIGNMENT_REQUIRED:
//	True or false (1 or 0) whether or not the hardware requires the ABI
//	alignment.
//
// _LONG_LONG_ALIGNMENT_32
//	The 32-bit ABI supported by a 64-bit kernel may have different
//	alignment requirements for primitive object types.  The value of this
//	identifier is expressed in "byte-alignment" units.
//
// _HAVE_CPUID_INSN
//	This indicates that the architecture supports the 'cpuid'
//	instruction as defined by Intel.  (Intel allows other vendors
//	to extend the instruction for their own purposes.)
//
//
// Implementation Choices:
//
// _ILP32 / _LP64:
//	This specifies the compiler data type implementation as specified in
//	the relevant ABI.  The choice between these is strongly influenced
//	by the underlying hardware, but is not absolutely tied to it.
//	Currently only two data type models are supported:
//
//	_ILP32:
//		Int/Long/Pointer are 32 bits.  This is the historical UNIX
//		and Solaris implementation.  Due to its historical standing,
//		this is the default case.
//
//	_LP64:
//		Long/Pointer are 64 bits, Int is 32 bits.  This is the chosen
//		implementation for 64-bit ABIs such as SPARC V9.
//
//	_I32LPx:
//		A compilation environment where 'int' is 32-bit, and
//		longs and pointers are simply the same size.
//
//	In all cases, Char is 8 bits and Short is 16 bits.
//
// _SUNOS_VTOC_8 / _SUNOS_VTOC_16 / _SVR4_VTOC_16:
//	This specifies the form of the disk VTOC (or label):
//
//	_SUNOS_VTOC_8:
//		This is a VTOC form which is upwardly compatible with the
//		SunOS 4.x disk label and allows 8 partitions per disk.
//
//	_SUNOS_VTOC_16:
//		In this format the incore vtoc image matches the ondisk
//		version.  It allows 16 slices per disk, and is not
//		compatible with the SunOS 4.x disk label.
//
//	Note that these are not the only two VTOC forms possible and
//	additional forms may be added.  One possible form would be the
//	SVr4 VTOC form.  The symbol for that is reserved now, although
//	it is not implemented.
//
//	_SVR4_VTOC_16:
//		This VTOC form is compatible with the System V Release 4
//		VTOC (as implemented on the SVr4 Intel and 3b ports) with
//		16 partitions per disk.
//
//
// _DMA_USES_PHYSADDR / _DMA_USES_VIRTADDR
//	This describes the type of addresses used by system DMA:
//
//	_DMA_USES_PHYSADDR:
//		This type of DMA, used in the x86 implementation,
//		requires physical addresses for DMA buffers.  The 24-bit
//		addresses used by some legacy boards is the source of the
//		"low-memory" (<16MB) requirement for some devices using DMA.
//
//	_DMA_USES_VIRTADDR:
//		This method of DMA allows the use of virtual addresses for
//		DMA transfers.
//
// _FIRMWARE_NEEDS_FDISK / _NO_FDISK_PRESENT
//      This indicates the presence/absence of an fdisk table.
//
//      _FIRMWARE_NEEDS_FDISK
//              The fdisk table is required by system firmware.  If present,
//              it allows a disk to be subdivided into multiple fdisk
//              partitions, each of which is equivalent to a separate,
//              virtual disk.  This enables the co-existence of multiple
//              operating systems on a shared hard disk.
//
//      _NO_FDISK_PRESENT
//              If the fdisk table is absent, it is assumed that the entire
//              media is allocated for a single operating system.
//
// _HAVE_TEM_FIRMWARE
//	Defined if this architecture has the (fallback) option of
//	using prom_* calls for doing I/O if a suitable kernel driver
//	is not available to do it.
//
// _DONT_USE_1275_GENERIC_NAMES
//		Controls whether or not device tree node names should
//		comply with the IEEE 1275 "Generic Names" Recommended
//		Practice. With _DONT_USE_GENERIC_NAMES, device-specific
//		names identifying the particular device will be used.
//
// __i386_COMPAT
//	This indicates whether the i386 ABI is supported as a *non-native*
//	mode for the platform.  When this symbol is defined:
//	-	32-bit xstat-style system calls are enabled
//	-	32-bit xmknod-style system calls are enabled
//	-	32-bit system calls use i386 sizes -and- alignments
//
//	Note that this is NOT defined for the i386 native environment!
//
// __x86
//	This is ONLY a synonym for defined(__i386) || defined(__amd64)
//	which is useful only insofar as these two architectures share
//	common attributes.  Analogous to __sparc.
//
// _PSM_MODULES
//	This indicates whether or not the implementation uses PSM
//	modules for processor support, reading /etc/mach from inside
//	the kernel to extract a list.
//
// _RTC_CONFIG
//	This indicates whether or not the implementation uses /etc/rtc_config
//	to configure the real-time clock in the kernel.
//
// _UNIX_KRTLD
//	This indicates that the implementation uses a dynamically
//	linked unix + krtld to form the core kernel image at boot
//	time, or (in the absence of this symbol) a prelinked kernel image.
//
// _OBP
//	This indicates the firmware interface is OBP.
//
// _SOFT_HOSTID
//	This indicates that the implementation obtains the hostid
//	from the file /etc/hostid, rather than from hardware.

// The following set of definitions characterize Solaris on AMD's
// 64-bit systems.

// Define the appropriate "processor characteristics"

// Different alignment constraints for the i386 ABI in compatibility mode

// Define the appropriate "implementation choices".

// The feature test macro __i386 is generic for all processors implementing
// the Intel 386 instruction set or a superset of it.  Specifically, this
// includes all members of the 386, 486, and Pentium family of processors.

// Values of _POSIX_C_SOURCE
//
//		undefined   not a POSIX compilation
//		1	    POSIX.1-1990 compilation
//		2	    POSIX.2-1992 compilation
//		199309L	    POSIX.1b-1993 compilation (Real Time)
//		199506L	    POSIX.1c-1995 compilation (POSIX Threads)
//		200112L	    POSIX.1-2001 compilation (Austin Group Revision)
//		200809L     POSIX.1-2008 compilation

// The feature test macros __XOPEN_OR_POSIX, _STRICT_STDC, _STRICT_SYMBOLS,
// and _STDC_C99 are Sun implementation specific macros created in order to
// compress common standards specified feature test macros for easier reading.
// These macros should not be used by the application developer as
// unexpected results may occur. Instead, the user should reference
// standards(7) for correct usage of the standards feature test macros.
//
// __XOPEN_OR_POSIX     Used in cases where a symbol is defined by both
//                      X/Open or POSIX or in the negative, when neither
//                      X/Open or POSIX defines a symbol.
//
// _STRICT_STDC         __STDC__ is specified by the C Standards and defined
//                      by the compiler. For Sun compilers the value of
//                      __STDC__ is either 1, 0, or not defined based on the
//                      compilation mode (see cc(1)). When the value of
//                      __STDC__ is 1 and in the absence of any other feature
//                      test macros, the namespace available to the application
//                      is limited to only those symbols defined by the C
//                      Standard. _STRICT_STDC provides a more readable means
//                      of identifying symbols defined by the standard, or in
//                      the negative, symbols that are extensions to the C
//                      Standard. See additional comments for GNU C differences.
//
// _STDC_C99            __STDC_VERSION__ is specified by the C standards and
//                      defined by the compiler and indicates the version of
//                      the C standard. A value of 199901L indicates a
//                      compiler that complies with ISO/IEC 9899:1999, other-
//                      wise known as the C99 standard.
//
// _STDC_C11		Like _STDC_C99 except that the value of __STDC_VERSION__
//                      is 201112L indicating a compiler that compiles with
//                      ISO/IEC 9899:2011, otherwise known as the C11 standard.
//
// _STRICT_SYMBOLS	Used in cases where symbol visibility is restricted
//                      by the standards, and the user has not explicitly
//                      relaxed the strictness via __EXTENSIONS__.

// ISO/IEC 9899:1990 and it's revisions, ISO/IEC 9899:1999 and ISO/IEC
// 99899:2011 specify the following predefined macro name:
//
// __STDC__	The integer constant 1, intended to indicate a conforming
//		implementation.
//
// Furthermore, a strictly conforming program shall use only those features
// of the language and library specified in these standards. A conforming
// implementation shall accept any strictly conforming program.
//
// Based on these requirements, Sun's C compiler defines __STDC__ to 1 for
// strictly conforming environments and __STDC__ to 0 for environments that
// use ANSI C semantics but allow extensions to the C standard. For non-ANSI
// C semantics, Sun's C compiler does not define __STDC__.
//
// The GNU C project interpretation is that __STDC__ should always be defined
// to 1 for compilation modes that accept ANSI C syntax regardless of whether
// or not extensions to the C standard are used. Violations of conforming
// behavior are conditionally flagged as warnings via the use of the
// -pedantic option. In addition to defining __STDC__ to 1, the GNU C
// compiler also defines __STRICT_ANSI__ as a means of specifying strictly
// conforming environments using the -ansi or -std=<standard> options.
//
// In the absence of any other compiler options, Sun and GNU set the value
// of __STDC__ as follows when using the following options:
//
//				Value of __STDC__  __STRICT_ANSI__
//
// cc -Xa (default)			0	      undefined
// cc -Xt (transitional)		0             undefined
// cc -Xc (strictly conforming)		1	      undefined
// cc -Xs (K&R C)		    undefined	      undefined
//
// gcc (default)			1	      undefined
// gcc -ansi, -std={c89, c99,...)	1               defined
// gcc -traditional (K&R)	    undefined	      undefined
//
// The default compilation modes for Sun C compilers versus GNU C compilers
// results in a differing value for __STDC__ which results in a more
// restricted namespace when using Sun compilers. To allow both GNU and Sun
// interpretations to peacefully co-exist, we use the following Sun
// implementation _STRICT_STDC_ macro:

// Compiler complies with ISO/IEC 9899:1999 or ISO/IEC 9989:2011

// Use strict symbol visibility.

// This is a variant of _STRICT_SYMBOLS that is meant to cover headers that are
// governed by POSIX, but have not been governed by ISO C. One can go two ways
// on what should happen if an application actively includes (not transitively)
// a header that isn't part of the ISO C spec, we opt to say that if someone has
// gone out of there way then they're doing it for a reason and that is an act
// of non-compliance and therefore it's not up to us to hide away every symbol.
//
// In general, prefer using _STRICT_SYMBOLS, but this is here in particular for
// cases where in the past we have only used a POSIX related check and we don't
// wish to make something stricter. Often applications are relying on the
// ability to, or more realistically unwittingly, have _STRICT_STDC declared and
// still use these interfaces.

// Large file interfaces:
//
//	_LARGEFILE_SOURCE
//		1		large file-related additions to POSIX
//				interfaces requested (fseeko, etc.)
//	_LARGEFILE64_SOURCE
//		1		transitional large-file-related interfaces
//				requested (seek64, stat64, etc.)
//
// The corresponding announcement macros are respectively:
//	_LFS_LARGEFILE
//	_LFS64_LARGEFILE
// (These are set in <unistd.h>.)
//
// Requesting _LARGEFILE64_SOURCE implies requesting _LARGEFILE_SOURCE as
// well.
//
// The large file interfaces are made visible regardless of the initial values
// of the feature test macros under certain circumstances:
//    -	If no explicit standards-conforming environment is requested (neither
//	of _POSIX_SOURCE nor _XOPEN_SOURCE is defined and the value of
//	__STDC__ does not imply standards conformance).
//    -	Extended system interfaces are explicitly requested (__EXTENSIONS__
//	is defined).
//    -	Access to in-kernel interfaces is requested (_KERNEL or _KMEMUSER is
//	defined).  (Note that this dependency is an artifact of the current
//	kernel implementation and may change in future releases.)

// Large file compilation environment control:
//
// The setting of _FILE_OFFSET_BITS controls the size of various file-related
// types and governs the mapping between file-related source function symbol
// names and the corresponding binary entry points.
//
// In the 32-bit environment, the default value is 32; if not set, set it to
// the default here, to simplify tests in other headers.
//
// In the 64-bit compilation environment, the only value allowed is 64.

// Use of _XOPEN_SOURCE
//
// The following X/Open specifications are supported:
//
// X/Open Portability Guide, Issue 3 (XPG3)
// X/Open CAE Specification, Issue 4 (XPG4)
// X/Open CAE Specification, Issue 4, Version 2 (XPG4v2)
// X/Open CAE Specification, Issue 5 (XPG5)
// Open Group Technical Standard, Issue 6 (XPG6), also referred to as
//    IEEE Std. 1003.1-2001 and ISO/IEC 9945:2002.
// Open Group Technical Standard, Issue 7 (XPG7), also referred to as
//    IEEE Std. 1003.1-2008 and ISO/IEC 9945:2009.
//
// XPG4v2 is also referred to as UNIX 95 (SUS or SUSv1).
// XPG5 is also referred to as UNIX 98 or the Single Unix Specification,
//     Version 2 (SUSv2)
// XPG6 is the result of a merge of the X/Open and POSIX specifications
//     and as such is also referred to as IEEE Std. 1003.1-2001 in
//     addition to UNIX 03 and SUSv3.
// XPG7 is also referred to as UNIX 08 and SUSv4.
//
// When writing a conforming X/Open application, as per the specification
// requirements, the appropriate feature test macros must be defined at
// compile time. These are as follows. For more info, see standards(7).
//
// Feature Test Macro				     Specification
// ------------------------------------------------  -------------
// _XOPEN_SOURCE                                         XPG3
// _XOPEN_SOURCE && _XOPEN_VERSION = 4                   XPG4
// _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED = 1           XPG4v2
// _XOPEN_SOURCE = 500                                   XPG5
// _XOPEN_SOURCE = 600  (or POSIX_C_SOURCE=200112L)      XPG6
// _XOPEN_SOURCE = 700  (or POSIX_C_SOURCE=200809L)      XPG7
//
// In order to simplify the guards within the headers, the following
// implementation private test macros have been created. Applications
// must NOT use these private test macros as unexpected results will
// occur.
//
// Note that in general, the use of these private macros is cumulative.
// For example, the use of _XPG3 with no other restrictions on the X/Open
// namespace will make the symbols visible for XPG3 through XPG6
// compilation environments. The use of _XPG4_2 with no other X/Open
// namespace restrictions indicates that the symbols were introduced in
// XPG4v2 and are therefore visible for XPG4v2 through XPG6 compilation
// environments, but not for XPG3 or XPG4 compilation environments.
//
// _XPG3    X/Open Portability Guide, Issue 3 (XPG3)
// _XPG4    X/Open CAE Specification, Issue 4 (XPG4)
// _XPG4_2  X/Open CAE Specification, Issue 4, Version 2 (XPG4v2/UNIX 95/SUS)
// _XPG5    X/Open CAE Specification, Issue 5 (XPG5/UNIX 98/SUSv2)
// _XPG6    Open Group Technical Standard, Issue 6 (XPG6/UNIX 03/SUSv3)
// _XPG7    Open Group Technical Standard, Issue 7 (XPG7/UNIX 08/SUSv4)

// X/Open Portability Guide, Issue 3

// _XOPEN_VERSION is defined by the X/Open specifications and is not
// normally defined by the application, except in the case of an XPG4
// application.  On the implementation side, _XOPEN_VERSION defined with
// the value of 3 indicates an XPG3 application. _XOPEN_VERSION defined
// with the value of 4 indicates an XPG4 or XPG4v2 (UNIX 95) application.
// _XOPEN_VERSION  defined with a value of 500 indicates an XPG5 (UNIX 98)
// application and with a value of 600 indicates an XPG6 (UNIX 03)
// application and with a value of 700 indicates an XPG7 (UNIX 08).
// The appropriate version is determined by the use of the
// feature test macros described earlier.  The value of _XOPEN_VERSION
// defaults to 3 otherwise indicating support for XPG3 applications.

// ANSI C and ISO 9899:1990 say the type long long doesn't exist in strictly
// conforming environments.  ISO 9899:1999 says it does.
//
// The presence of _LONGLONG_TYPE says "long long exists" which is therefore
// defined in all but strictly conforming environments that disallow it.

// The following macro defines a value for the ISO C99 restrict
// keyword so that _RESTRICT_KYWD resolves to "restrict" if
// an ISO C99 compiler is used, "__restrict" for c++ and "" (null string)
// if any other compiler is used. This allows for the use of single
// prototype declarations regardless of compiler version.

// The following macro defines a value for the ISO C11 _Noreturn
// keyword so that _NORETURN_KYWD resolves to "_Noreturn" if
// an ISO C11 compiler is used and "" (null string) if any other
// compiler is used. This allows for the use of single prototype
// declarations regardless of compiler version.

// ISO/IEC 9899:2011 Annex K

// The following macro indicates header support for the ANSI C++
// standard.  The ISO/IEC designation for this is ISO/IEC FDIS 14882.

// The following macro indicates header support for the C99 standard,
// ISO/IEC 9899:1999, Programming Languages - C.

// The following macro indicates header support for the C11 standard,
// ISO/IEC 9899:2011, Programming Languages - C.

// The following macro indicates header support for the C11 standard,
// ISO/IEC 9899:2011 Annex K, Programming Languages - C.

// The following macro indicates header support for DTrace. The value is an
// integer that corresponds to the major version number for DTrace.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2016 Joyent, Inc.

// Machine dependent definitions moved to <sys/machtypes.h>.
// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Machine dependent types:
//
//	intel ia32 Version

type X_label_t = struct{ Fval [8]int64 } /* machtypes.h:59:9 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
// Copyright 2016 Toomas Soome <tsoome@me.com>
// Copyright (c) 2016, 2017 by Delphix. All rights reserved.
// Copyright 2016 Nexenta Systems, Inc.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Portions of this source code were derived from Berkeley 4.3 BSD
// under license from the Regents of the University of California.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
// Copyright 2014 Igor Kozhukhov <ikozhukhov@gmail.com>.
// Copyright 2019 Nexenta Systems, Inc. All rights reserved.
// Copyright 2020 Joyent, Inc.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2015 EveryCity Ltd. All rights reserved.
// Copyright 2019 Joyent, Inc.

// This file contains definitions designed to enable different compilers
// to be used harmoniously on Solaris systems.

// Allow for version tests for compiler bugs and features.

// analogous to lint's PRINTFLIKEn

// Handle the kernel printf routines that can take '%b' too

// This one's pretty obvious -- the function never returns

// The function is 'extern inline' and expects GNU C89 behaviour, not C99
// behaviour.
//
// Should only be used on 'extern inline' definitions for GCC.

// The function has control flow such that it may return multiple times (in
// the manner of setjmp or vfork)

// This is an appropriate label for functions that do not
// modify their arguments, e.g. strlen()

// This is a stronger form of __pure__. Can be used for functions
// that do not modify their arguments and don't depend on global
// memory.

// This attribute, attached to a variable, means that the variable is meant to
// be possibly unused. GCC will not produce a warning for this variable.

// Shorthand versions for readability

// In release build, disable warnings about variables
// which are used only for debugging.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2016 Joyent, Inc.

// This header file serves to group a set of well known defines and to
// set these for each instruction set architecture.  These defines may
// be divided into two groups;  characteristics of the processor and
// implementation choices for Solaris on a processor.
//
// Processor Characteristics:
//
// _LITTLE_ENDIAN / _BIG_ENDIAN:
//	The natural byte order of the processor.  A pointer to an int points
//	to the least/most significant byte of that int.
//
// _STACK_GROWS_UPWARD / _STACK_GROWS_DOWNWARD:
//	The processor specific direction of stack growth.  A push onto the
//	stack increases/decreases the stack pointer, so it stores data at
//	successively higher/lower addresses.  (Stackless machines ignored
//	without regrets).
//
// _LONG_LONG_HTOL / _LONG_LONG_LTOH:
//	A pointer to a long long points to the most/least significant long
//	within that long long.
//
// _BIT_FIELDS_HTOL / _BIT_FIELDS_LTOH:
//	The C compiler assigns bit fields from the high/low to the low/high end
//	of an int (most to least significant vs. least to most significant).
//
// _IEEE_754:
//	The processor (or supported implementations of the processor)
//	supports the ieee-754 floating point standard.  No other floating
//	point standards are supported (or significant).  Any other supported
//	floating point formats are expected to be cased on the ISA processor
//	symbol.
//
// _CHAR_IS_UNSIGNED / _CHAR_IS_SIGNED:
//	The C Compiler implements objects of type `char' as `unsigned' or
//	`signed' respectively.  This is really an implementation choice of
//	the compiler writer, but it is specified in the ABI and tends to
//	be uniform across compilers for an instruction set architecture.
//	Hence, it has the properties of a processor characteristic.
//
// _CHAR_ALIGNMENT / _SHORT_ALIGNMENT / _INT_ALIGNMENT / _LONG_ALIGNMENT /
// _LONG_LONG_ALIGNMENT / _DOUBLE_ALIGNMENT / _LONG_DOUBLE_ALIGNMENT /
// _POINTER_ALIGNMENT / _FLOAT_ALIGNMENT:
//	The ABI defines alignment requirements of each of the primitive
//	object types.  Some, if not all, may be hardware requirements as
// 	well.  The values are expressed in "byte-alignment" units.
//
// _MAX_ALIGNMENT:
//	The most stringent alignment requirement as specified by the ABI.
//	Equal to the maximum of all the above _XXX_ALIGNMENT values.
//
// _MAX_ALIGNMENT_TYPE:
// 	The name of the C type that has the value descried in _MAX_ALIGNMENT.
//
// _ALIGNMENT_REQUIRED:
//	True or false (1 or 0) whether or not the hardware requires the ABI
//	alignment.
//
// _LONG_LONG_ALIGNMENT_32
//	The 32-bit ABI supported by a 64-bit kernel may have different
//	alignment requirements for primitive object types.  The value of this
//	identifier is expressed in "byte-alignment" units.
//
// _HAVE_CPUID_INSN
//	This indicates that the architecture supports the 'cpuid'
//	instruction as defined by Intel.  (Intel allows other vendors
//	to extend the instruction for their own purposes.)
//
//
// Implementation Choices:
//
// _ILP32 / _LP64:
//	This specifies the compiler data type implementation as specified in
//	the relevant ABI.  The choice between these is strongly influenced
//	by the underlying hardware, but is not absolutely tied to it.
//	Currently only two data type models are supported:
//
//	_ILP32:
//		Int/Long/Pointer are 32 bits.  This is the historical UNIX
//		and Solaris implementation.  Due to its historical standing,
//		this is the default case.
//
//	_LP64:
//		Long/Pointer are 64 bits, Int is 32 bits.  This is the chosen
//		implementation for 64-bit ABIs such as SPARC V9.
//
//	_I32LPx:
//		A compilation environment where 'int' is 32-bit, and
//		longs and pointers are simply the same size.
//
//	In all cases, Char is 8 bits and Short is 16 bits.
//
// _SUNOS_VTOC_8 / _SUNOS_VTOC_16 / _SVR4_VTOC_16:
//	This specifies the form of the disk VTOC (or label):
//
//	_SUNOS_VTOC_8:
//		This is a VTOC form which is upwardly compatible with the
//		SunOS 4.x disk label and allows 8 partitions per disk.
//
//	_SUNOS_VTOC_16:
//		In this format the incore vtoc image matches the ondisk
//		version.  It allows 16 slices per disk, and is not
//		compatible with the SunOS 4.x disk label.
//
//	Note that these are not the only two VTOC forms possible and
//	additional forms may be added.  One possible form would be the
//	SVr4 VTOC form.  The symbol for that is reserved now, although
//	it is not implemented.
//
//	_SVR4_VTOC_16:
//		This VTOC form is compatible with the System V Release 4
//		VTOC (as implemented on the SVr4 Intel and 3b ports) with
//		16 partitions per disk.
//
//
// _DMA_USES_PHYSADDR / _DMA_USES_VIRTADDR
//	This describes the type of addresses used by system DMA:
//
//	_DMA_USES_PHYSADDR:
//		This type of DMA, used in the x86 implementation,
//		requires physical addresses for DMA buffers.  The 24-bit
//		addresses used by some legacy boards is the source of the
//		"low-memory" (<16MB) requirement for some devices using DMA.
//
//	_DMA_USES_VIRTADDR:
//		This method of DMA allows the use of virtual addresses for
//		DMA transfers.
//
// _FIRMWARE_NEEDS_FDISK / _NO_FDISK_PRESENT
//      This indicates the presence/absence of an fdisk table.
//
//      _FIRMWARE_NEEDS_FDISK
//              The fdisk table is required by system firmware.  If present,
//              it allows a disk to be subdivided into multiple fdisk
//              partitions, each of which is equivalent to a separate,
//              virtual disk.  This enables the co-existence of multiple
//              operating systems on a shared hard disk.
//
//      _NO_FDISK_PRESENT
//              If the fdisk table is absent, it is assumed that the entire
//              media is allocated for a single operating system.
//
// _HAVE_TEM_FIRMWARE
//	Defined if this architecture has the (fallback) option of
//	using prom_* calls for doing I/O if a suitable kernel driver
//	is not available to do it.
//
// _DONT_USE_1275_GENERIC_NAMES
//		Controls whether or not device tree node names should
//		comply with the IEEE 1275 "Generic Names" Recommended
//		Practice. With _DONT_USE_GENERIC_NAMES, device-specific
//		names identifying the particular device will be used.
//
// __i386_COMPAT
//	This indicates whether the i386 ABI is supported as a *non-native*
//	mode for the platform.  When this symbol is defined:
//	-	32-bit xstat-style system calls are enabled
//	-	32-bit xmknod-style system calls are enabled
//	-	32-bit system calls use i386 sizes -and- alignments
//
//	Note that this is NOT defined for the i386 native environment!
//
// __x86
//	This is ONLY a synonym for defined(__i386) || defined(__amd64)
//	which is useful only insofar as these two architectures share
//	common attributes.  Analogous to __sparc.
//
// _PSM_MODULES
//	This indicates whether or not the implementation uses PSM
//	modules for processor support, reading /etc/mach from inside
//	the kernel to extract a list.
//
// _RTC_CONFIG
//	This indicates whether or not the implementation uses /etc/rtc_config
//	to configure the real-time clock in the kernel.
//
// _UNIX_KRTLD
//	This indicates that the implementation uses a dynamically
//	linked unix + krtld to form the core kernel image at boot
//	time, or (in the absence of this symbol) a prelinked kernel image.
//
// _OBP
//	This indicates the firmware interface is OBP.
//
// _SOFT_HOSTID
//	This indicates that the implementation obtains the hostid
//	from the file /etc/hostid, rather than from hardware.

// The following set of definitions characterize Solaris on AMD's
// 64-bit systems.

// Define the appropriate "processor characteristics"

// Different alignment constraints for the i386 ABI in compatibility mode

// Define the appropriate "implementation choices".

// The feature test macro __i386 is generic for all processors implementing
// the Intel 386 instruction set or a superset of it.  Specifically, this
// includes all members of the 386, 486, and Pentium family of processors.

// Values of _POSIX_C_SOURCE
//
//		undefined   not a POSIX compilation
//		1	    POSIX.1-1990 compilation
//		2	    POSIX.2-1992 compilation
//		199309L	    POSIX.1b-1993 compilation (Real Time)
//		199506L	    POSIX.1c-1995 compilation (POSIX Threads)
//		200112L	    POSIX.1-2001 compilation (Austin Group Revision)
//		200809L     POSIX.1-2008 compilation

// The feature test macros __XOPEN_OR_POSIX, _STRICT_STDC, _STRICT_SYMBOLS,
// and _STDC_C99 are Sun implementation specific macros created in order to
// compress common standards specified feature test macros for easier reading.
// These macros should not be used by the application developer as
// unexpected results may occur. Instead, the user should reference
// standards(7) for correct usage of the standards feature test macros.
//
// __XOPEN_OR_POSIX     Used in cases where a symbol is defined by both
//                      X/Open or POSIX or in the negative, when neither
//                      X/Open or POSIX defines a symbol.
//
// _STRICT_STDC         __STDC__ is specified by the C Standards and defined
//                      by the compiler. For Sun compilers the value of
//                      __STDC__ is either 1, 0, or not defined based on the
//                      compilation mode (see cc(1)). When the value of
//                      __STDC__ is 1 and in the absence of any other feature
//                      test macros, the namespace available to the application
//                      is limited to only those symbols defined by the C
//                      Standard. _STRICT_STDC provides a more readable means
//                      of identifying symbols defined by the standard, or in
//                      the negative, symbols that are extensions to the C
//                      Standard. See additional comments for GNU C differences.
//
// _STDC_C99            __STDC_VERSION__ is specified by the C standards and
//                      defined by the compiler and indicates the version of
//                      the C standard. A value of 199901L indicates a
//                      compiler that complies with ISO/IEC 9899:1999, other-
//                      wise known as the C99 standard.
//
// _STDC_C11		Like _STDC_C99 except that the value of __STDC_VERSION__
//                      is 201112L indicating a compiler that compiles with
//                      ISO/IEC 9899:2011, otherwise known as the C11 standard.
//
// _STRICT_SYMBOLS	Used in cases where symbol visibility is restricted
//                      by the standards, and the user has not explicitly
//                      relaxed the strictness via __EXTENSIONS__.

// ISO/IEC 9899:1990 and it's revisions, ISO/IEC 9899:1999 and ISO/IEC
// 99899:2011 specify the following predefined macro name:
//
// __STDC__	The integer constant 1, intended to indicate a conforming
//		implementation.
//
// Furthermore, a strictly conforming program shall use only those features
// of the language and library specified in these standards. A conforming
// implementation shall accept any strictly conforming program.
//
// Based on these requirements, Sun's C compiler defines __STDC__ to 1 for
// strictly conforming environments and __STDC__ to 0 for environments that
// use ANSI C semantics but allow extensions to the C standard. For non-ANSI
// C semantics, Sun's C compiler does not define __STDC__.
//
// The GNU C project interpretation is that __STDC__ should always be defined
// to 1 for compilation modes that accept ANSI C syntax regardless of whether
// or not extensions to the C standard are used. Violations of conforming
// behavior are conditionally flagged as warnings via the use of the
// -pedantic option. In addition to defining __STDC__ to 1, the GNU C
// compiler also defines __STRICT_ANSI__ as a means of specifying strictly
// conforming environments using the -ansi or -std=<standard> options.
//
// In the absence of any other compiler options, Sun and GNU set the value
// of __STDC__ as follows when using the following options:
//
//				Value of __STDC__  __STRICT_ANSI__
//
// cc -Xa (default)			0	      undefined
// cc -Xt (transitional)		0             undefined
// cc -Xc (strictly conforming)		1	      undefined
// cc -Xs (K&R C)		    undefined	      undefined
//
// gcc (default)			1	      undefined
// gcc -ansi, -std={c89, c99,...)	1               defined
// gcc -traditional (K&R)	    undefined	      undefined
//
// The default compilation modes for Sun C compilers versus GNU C compilers
// results in a differing value for __STDC__ which results in a more
// restricted namespace when using Sun compilers. To allow both GNU and Sun
// interpretations to peacefully co-exist, we use the following Sun
// implementation _STRICT_STDC_ macro:

// Compiler complies with ISO/IEC 9899:1999 or ISO/IEC 9989:2011

// Use strict symbol visibility.

// This is a variant of _STRICT_SYMBOLS that is meant to cover headers that are
// governed by POSIX, but have not been governed by ISO C. One can go two ways
// on what should happen if an application actively includes (not transitively)
// a header that isn't part of the ISO C spec, we opt to say that if someone has
// gone out of there way then they're doing it for a reason and that is an act
// of non-compliance and therefore it's not up to us to hide away every symbol.
//
// In general, prefer using _STRICT_SYMBOLS, but this is here in particular for
// cases where in the past we have only used a POSIX related check and we don't
// wish to make something stricter. Often applications are relying on the
// ability to, or more realistically unwittingly, have _STRICT_STDC declared and
// still use these interfaces.

// Large file interfaces:
//
//	_LARGEFILE_SOURCE
//		1		large file-related additions to POSIX
//				interfaces requested (fseeko, etc.)
//	_LARGEFILE64_SOURCE
//		1		transitional large-file-related interfaces
//				requested (seek64, stat64, etc.)
//
// The corresponding announcement macros are respectively:
//	_LFS_LARGEFILE
//	_LFS64_LARGEFILE
// (These are set in <unistd.h>.)
//
// Requesting _LARGEFILE64_SOURCE implies requesting _LARGEFILE_SOURCE as
// well.
//
// The large file interfaces are made visible regardless of the initial values
// of the feature test macros under certain circumstances:
//    -	If no explicit standards-conforming environment is requested (neither
//	of _POSIX_SOURCE nor _XOPEN_SOURCE is defined and the value of
//	__STDC__ does not imply standards conformance).
//    -	Extended system interfaces are explicitly requested (__EXTENSIONS__
//	is defined).
//    -	Access to in-kernel interfaces is requested (_KERNEL or _KMEMUSER is
//	defined).  (Note that this dependency is an artifact of the current
//	kernel implementation and may change in future releases.)

// Large file compilation environment control:
//
// The setting of _FILE_OFFSET_BITS controls the size of various file-related
// types and governs the mapping between file-related source function symbol
// names and the corresponding binary entry points.
//
// In the 32-bit environment, the default value is 32; if not set, set it to
// the default here, to simplify tests in other headers.
//
// In the 64-bit compilation environment, the only value allowed is 64.

// Use of _XOPEN_SOURCE
//
// The following X/Open specifications are supported:
//
// X/Open Portability Guide, Issue 3 (XPG3)
// X/Open CAE Specification, Issue 4 (XPG4)
// X/Open CAE Specification, Issue 4, Version 2 (XPG4v2)
// X/Open CAE Specification, Issue 5 (XPG5)
// Open Group Technical Standard, Issue 6 (XPG6), also referred to as
//    IEEE Std. 1003.1-2001 and ISO/IEC 9945:2002.
// Open Group Technical Standard, Issue 7 (XPG7), also referred to as
//    IEEE Std. 1003.1-2008 and ISO/IEC 9945:2009.
//
// XPG4v2 is also referred to as UNIX 95 (SUS or SUSv1).
// XPG5 is also referred to as UNIX 98 or the Single Unix Specification,
//     Version 2 (SUSv2)
// XPG6 is the result of a merge of the X/Open and POSIX specifications
//     and as such is also referred to as IEEE Std. 1003.1-2001 in
//     addition to UNIX 03 and SUSv3.
// XPG7 is also referred to as UNIX 08 and SUSv4.
//
// When writing a conforming X/Open application, as per the specification
// requirements, the appropriate feature test macros must be defined at
// compile time. These are as follows. For more info, see standards(7).
//
// Feature Test Macro				     Specification
// ------------------------------------------------  -------------
// _XOPEN_SOURCE                                         XPG3
// _XOPEN_SOURCE && _XOPEN_VERSION = 4                   XPG4
// _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED = 1           XPG4v2
// _XOPEN_SOURCE = 500                                   XPG5
// _XOPEN_SOURCE = 600  (or POSIX_C_SOURCE=200112L)      XPG6
// _XOPEN_SOURCE = 700  (or POSIX_C_SOURCE=200809L)      XPG7
//
// In order to simplify the guards within the headers, the following
// implementation private test macros have been created. Applications
// must NOT use these private test macros as unexpected results will
// occur.
//
// Note that in general, the use of these private macros is cumulative.
// For example, the use of _XPG3 with no other restrictions on the X/Open
// namespace will make the symbols visible for XPG3 through XPG6
// compilation environments. The use of _XPG4_2 with no other X/Open
// namespace restrictions indicates that the symbols were introduced in
// XPG4v2 and are therefore visible for XPG4v2 through XPG6 compilation
// environments, but not for XPG3 or XPG4 compilation environments.
//
// _XPG3    X/Open Portability Guide, Issue 3 (XPG3)
// _XPG4    X/Open CAE Specification, Issue 4 (XPG4)
// _XPG4_2  X/Open CAE Specification, Issue 4, Version 2 (XPG4v2/UNIX 95/SUS)
// _XPG5    X/Open CAE Specification, Issue 5 (XPG5/UNIX 98/SUSv2)
// _XPG6    Open Group Technical Standard, Issue 6 (XPG6/UNIX 03/SUSv3)
// _XPG7    Open Group Technical Standard, Issue 7 (XPG7/UNIX 08/SUSv4)

// X/Open Portability Guide, Issue 3

// _XOPEN_VERSION is defined by the X/Open specifications and is not
// normally defined by the application, except in the case of an XPG4
// application.  On the implementation side, _XOPEN_VERSION defined with
// the value of 3 indicates an XPG3 application. _XOPEN_VERSION defined
// with the value of 4 indicates an XPG4 or XPG4v2 (UNIX 95) application.
// _XOPEN_VERSION  defined with a value of 500 indicates an XPG5 (UNIX 98)
// application and with a value of 600 indicates an XPG6 (UNIX 03)
// application and with a value of 700 indicates an XPG7 (UNIX 08).
// The appropriate version is determined by the use of the
// feature test macros described earlier.  The value of _XOPEN_VERSION
// defaults to 3 otherwise indicating support for XPG3 applications.

// ANSI C and ISO 9899:1990 say the type long long doesn't exist in strictly
// conforming environments.  ISO 9899:1999 says it does.
//
// The presence of _LONGLONG_TYPE says "long long exists" which is therefore
// defined in all but strictly conforming environments that disallow it.

// The following macro defines a value for the ISO C99 restrict
// keyword so that _RESTRICT_KYWD resolves to "restrict" if
// an ISO C99 compiler is used, "__restrict" for c++ and "" (null string)
// if any other compiler is used. This allows for the use of single
// prototype declarations regardless of compiler version.

// The following macro defines a value for the ISO C11 _Noreturn
// keyword so that _NORETURN_KYWD resolves to "_Noreturn" if
// an ISO C11 compiler is used and "" (null string) if any other
// compiler is used. This allows for the use of single prototype
// declarations regardless of compiler version.

// ISO/IEC 9899:2011 Annex K

// The following macro indicates header support for the ANSI C++
// standard.  The ISO/IEC designation for this is ISO/IEC FDIS 14882.

// The following macro indicates header support for the C99 standard,
// ISO/IEC 9899:1999, Programming Languages - C.

// The following macro indicates header support for the C11 standard,
// ISO/IEC 9899:2011, Programming Languages - C.

// The following macro indicates header support for the C11 standard,
// ISO/IEC 9899:2011 Annex K, Programming Languages - C.

// The following macro indicates header support for DTrace. The value is an
// integer that corresponds to the major version number for DTrace.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2016 Joyent, Inc.

// Machine dependent definitions moved to <sys/machtypes.h>.
// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Machine dependent types:
//
//	intel ia32 Version

type Label_t = X_label_t /* machtypes.h:59:54 */

type Lock_t = uint8 /* machtypes.h:63:23 */ // lock work for busy wait

// Include fixed width type declarations proposed by the ISO/JTC1/SC22/WG14 C
// committee's working draft for the revision of the current ISO C standard,
// ISO/IEC 9899:1990 Programming language - C.  These are not currently
// required by any standard but constitute a useful, general purpose set
// of type definitions which is namespace clean with respect to all standards.
// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// This file, <sys/int_types.h>, is part of the Sun Microsystems implementation
// of <inttypes.h> defined in the ISO C standard, ISO/IEC 9899:1999
// Programming language - C.
//
// Programs/Modules should not directly include this file.  Access to the
// types defined in this file should be through the inclusion of one of the
// following files:
//
//	<sys/types.h>		Provides only the "_t" types defined in this
//				file which is a subset of the contents of
//				<inttypes.h>.  (This can be appropriate for
//				all programs/modules except those claiming
//				ANSI-C conformance.)
//
//	<sys/inttypes.h>	Provides the Kernel and Driver appropriate
//				components of <inttypes.h>.
//
//	<inttypes.h>		For use by applications.
//
// See these files for more details.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Basic / Extended integer types
//
// The following defines the basic fixed-size integer types.
//
// Implementations are free to typedef them to Standard C integer types or
// extensions that they support. If an implementation does not support one
// of the particular integer data types below, then it should not define the
// typedefs and macros corresponding to that data type.  Note that int8_t
// is not defined in -Xs mode on ISAs for which the ABI specifies "char"
// as an unsigned entity because there is no way to define an eight bit
// signed integral.
type Int8_t = int8   /* int_types.h:75:16 */
type Int16_t = int16 /* int_types.h:79:17 */
type Int32_t = int32 /* int_types.h:80:15 */
type Int64_t = int64 /* int_types.h:83:16 */

type Uint8_t = uint8   /* int_types.h:91:24 */
type Uint16_t = uint16 /* int_types.h:92:25 */
type Uint32_t = uint32 /* int_types.h:93:23 */
type Uint64_t = uint64 /* int_types.h:95:24 */

// intmax_t and uintmax_t are to be the longest (in number of bits) signed
// and unsigned integer types supported by the implementation.
type Intmax_t = int64   /* int_types.h:107:19 */
type Uintmax_t = uint64 /* int_types.h:108:19 */

// intptr_t and uintptr_t are signed and unsigned integer types large enough
// to hold any data pointer; that is, data pointers can be assigned into or
// from these integer types without losing precision.
type Intptr_t = int64   /* int_types.h:120:16 */
type Uintptr_t = uint64 /* int_types.h:121:24 */

// The following define the fastest integer types that can hold the
// specified number of bits.
type Int_fast8_t = int8   /* int_types.h:132:16 */
type Int_fast16_t = int32 /* int_types.h:136:15 */
type Int_fast32_t = int32 /* int_types.h:137:15 */
type Int_fast64_t = int64 /* int_types.h:139:16 */

type Uint_fast8_t = uint8   /* int_types.h:146:24 */
type Uint_fast16_t = uint32 /* int_types.h:147:23 */
type Uint_fast32_t = uint32 /* int_types.h:148:23 */
type Uint_fast64_t = uint64 /* int_types.h:150:24 */

// The following define the smallest integer types that can hold the
// specified number of bits.
type Int_least8_t = int8   /* int_types.h:162:16 */
type Int_least16_t = int16 /* int_types.h:166:17 */
type Int_least32_t = int32 /* int_types.h:167:15 */
type Int_least64_t = int64 /* int_types.h:169:16 */

// If these are changed, please update char16_t and char32_t in head/uchar.h.
type Uint_least8_t = uint8   /* int_types.h:179:24 */
type Uint_least16_t = uint16 /* int_types.h:180:25 */
type Uint_least32_t = uint32 /* int_types.h:181:23 */
type Uint_least64_t = uint64 /* int_types.h:183:24 */

// Strictly conforming ANSI C environments prior to the 1999
// revision of the C Standard (ISO/IEC 9899:1999) do not have
// the long long data type.
type Longlong_t = int64    /* types.h:72:20 */
type U_longlong_t = uint64 /* types.h:73:28 */

// These types (t_{u}scalar_t) exist because the XTI/TPI/DLPI standards had
// to use them instead of int32_t and uint32_t because DEC had
// shipped 64-bit wide.
type T_scalar_t = int32   /* types.h:92:18 */
type T_uscalar_t = uint32 /* types.h:93:18 */

// POSIX Extensions
type Uchar_t = uint8   /* types.h:102:23 */
type Ushort_t = uint16 /* types.h:103:24 */
type Uint_t = uint32   /* types.h:104:22 */
type Ulong_t = uint64  /* types.h:105:23 */

type Caddr_t = uintptr /* types.h:107:15 */ // ?<core address> type
type Daddr_t = int64   /* types.h:108:15 */ // <disk address> type
type Cnt_t = int16     /* types.h:109:16 */ // pointer difference

// VM-related types
type Pfn_t = uint64   /* types.h:123:18 */ // page frame number
type Pgcnt_t = uint64 /* types.h:124:18 */ // number of pages
type Spgcnt_t = int64 /* types.h:125:15 */ // signed number of pages

type Use_t = uint8          /* types.h:127:18 */ // use count for swap.
type Sysid_t = int16        /* types.h:128:16 */
type Index_t = int16        /* types.h:129:16 */
type Timeout_id_t = uintptr /* types.h:130:15 */ // opaque handle from timeout(9F)
type Bufcall_id_t = uintptr /* types.h:131:15 */ // opaque handle from bufcall(9F)

// The size of off_t and related types depends on the setting of
// _FILE_OFFSET_BITS.  (Note that other system headers define other types
// related to those defined here.)
//
// If _LARGEFILE64_SOURCE is defined, variants of these types that are
// explicitly 64 bits wide become available.

type Off_t = int64 /* types.h:145:15 */ // offsets within files

type Off64_t = int64 /* types.h:152:16 */ // offsets within files

type Ino_t = uint64      /* types.h:161:18 */ // expanded inode type
type Blkcnt_t = int64    /* types.h:162:15 */ // count of file blocks
type Fsblkcnt_t = uint64 /* types.h:163:18 */ // count of file system blocks
type Fsfilcnt_t = uint64 /* types.h:164:18 */ // count of files

type Ino64_t = uint64      /* types.h:174:16 */ // expanded inode type
type Blkcnt64_t = int64    /* types.h:175:18 */ // count of file blocks
type Fsblkcnt64_t = uint64 /* types.h:176:20 */ // count of file system blocks
type Fsfilcnt64_t = uint64 /* types.h:177:20 */ // count of files

type Blksize_t = int32 /* types.h:187:14 */ // used for block sizes

// The boolean_t type has had a varied amount of exposure over the years in
// terms of how its enumeration constants have been exposed. In particular, it
// originally used the __XOPEN_OR_POSIX macro to determine whether to prefix the
// B_TRUE and B_FALSE with an underscore. This check never included the
// question of if we were in a strict ANSI C environment or whether extensions
// were defined.
//
// Compilers such as clang started defaulting to always including an
// XOPEN_SOURCE declaration on behalf of users, but also noted __EXTENSIONS__.
// This would lead most software that had used the non-underscore versions to
// need it. As such, we have adjusted the non-strict XOPEN environment to retain
// its old behavior so as to minimize namespace pollution; however, we instead
// include both variants of the definitions in the generally visible version
// allowing software written in either world to hopefully end up in a good
// place.
//
// This isn't perfect, but should hopefully minimize the pain for folks actually
// trying to build software.
type Boolean_t = uint32 /* types.h:215:69 */

// The {u,}pad64_t types can be used in structures such that those structures
// may be accessed by code produced by compilation environments which don't
// support a 64 bit integral datatype.  The intention is not to allow
// use of these fields in such environments, but to maintain the alignment
// and offsets of the structure.
//
// Similar comments for {u,}pad128_t.
//
// Note that these types do NOT generate any stronger alignment constraints
// than those available in the underlying ABI.  See <sys/isa_defs.h>
type Pad64_t = int64   /* types.h:240:18 */
type Upad64_t = uint64 /* types.h:241:18 */

type Pad128_t = struct {
	F_q          float64
	F__ccgo_pad1 [8]byte
} /* types.h:257:3 */

type Upad128_t = struct {
	F_q          float64
	F__ccgo_pad1 [8]byte
} /* types.h:262:3 */

type Offset_t = int64    /* types.h:264:20 */
type U_offset_t = uint64 /* types.h:265:22 */
type Len_t = uint64      /* types.h:266:22 */
type Diskaddr_t = uint64 /* types.h:267:22 */

// Definitions remaining from previous partial support for 64-bit file
// offsets.  This partial support for devices greater than 2gb requires
// compiler support for long long.
type Lloff_t = struct{ F_f int64 } /* types.h:284:3 */

type Lldaddr_t = struct{ F_f int64 } /* types.h:304:3 */

type K_fltset_t = uint32 /* types.h:317:16 */ // kernel fault set type

// The following type is for various kinds of identifiers.  The
// actual type must be the same for all since some system calls
// (such as sigsend) take arguments that may be any of these
// types.  The enumeration type idtype_t defined in sys/procset.h
// is used to indicate what type of id is being specified --
// a process id, process group id, session id, scheduling class id,
// user id, group id, project id, task id or zone id.
type Id_t = int32 /* types.h:329:14 */

type Lgrp_id_t = int32 /* types.h:334:15 */ // lgroup ID

// Type useconds_t is an unsigned integral type capable of storing
// values at least in the range of zero to 1,000,000.
type Useconds_t = uint32 /* types.h:340:17 */ // Time, in microseconds

type Suseconds_t = int64 /* types.h:344:14 */ // signed # of microseconds

// Typedefs for dev_t components.
type Major_t = uint32 /* types.h:351:16 */ // major part of device number
type Minor_t = uint32 /* types.h:352:16 */ // minor part of device number

// The data type of a thread priority.
type Pri_t = int16 /* types.h:361:15 */

// The data type for a CPU flags field.  (Can be extended to larger unsigned
// types, if needed, limited by ability to update atomically.)
type Cpu_flag_t = uint16 /* types.h:367:18 */

// For compatibility reasons the following typedefs (prefixed o_)
// can't grow regardless of the EFT definition. Although,
// applications should not explicitly use these typedefs
// they may be included via a system header definition.
// WARNING: These typedefs may be removed in a future
// release.
//
//	ex. the definitions in s5inode.h (now obsoleted)
//		remained small to preserve compatibility
//		in the S5 file system type.
type O_mode_t = uint16 /* types.h:380:18 */ // old file attribute type
type O_dev_t = int16   /* types.h:381:15 */ // old device type
type O_uid_t = uint16  /* types.h:382:18 */ // old UID type
type O_gid_t = uint16  /* types.h:383:17 */ // old GID type
type O_nlink_t = int16 /* types.h:384:15 */ // old file link type
type O_pid_t = int16   /* types.h:385:15 */ // old process id type
type O_ino_t = uint16  /* types.h:386:18 */ // old inode type

// POSIX and XOPEN Declarations
type Key_t = int32   /* types.h:392:13 */ // IPC key type
type Mode_t = uint32 /* types.h:394:16 */ // file attribute type

type Uid_t = uint32 /* types.h:401:22 */ // UID type

type Gid_t = uint32 /* types.h:404:15 */ // GID type

type Datalink_id_t = uint32 /* types.h:406:18 */
type Vrid_t = uint32        /* types.h:407:18 */

type Taskid_t = int32 /* types.h:409:17 */
type Projid_t = int32 /* types.h:410:17 */
type Poolid_t = int32 /* types.h:411:14 */
type Zoneid_t = int32 /* types.h:412:14 */
type Ctid_t = int32   /* types.h:413:14 */

// POSIX definitions are same as defined in thread.h and synch.h.
// Any changes made to here should be reflected in corresponding
// files as described in comments.
type Pthread_t = uint32     /* types.h:420:16 */ // = thread_t in thread.h
type Pthread_key_t = uint32 /* types.h:421:16 */ // = thread_key_t in thread.h

// "Magic numbers" tagging synchronization object types

type X_pthread_mutex = struct {
	F__pthread_mutex_flags struct {
		F__pthread_mutex_flag1   uint16
		F__pthread_mutex_flag2   uint8
		F__pthread_mutex_ceiling uint8
		F__pthread_mutex_type    uint16
		F__pthread_mutex_magic   uint16
	}
	F__pthread_mutex_lock struct {
		F__ccgo_pad1            [0]uint64
		F__pthread_mutex_lock64 struct{ F__pthread_mutex_pad [8]uint8 }
	}
	F__pthread_mutex_data uint64
} /* types.h:429:9 */

// = thread_key_t in thread.h

// "Magic numbers" tagging synchronization object types

type Pthread_mutex_t = X_pthread_mutex /* types.h:448:3 */

type X_pthread_cond = struct {
	F__pthread_cond_flags struct {
		F__pthread_cond_flag  [4]uint8
		F__pthread_cond_type  uint16
		F__pthread_cond_magic uint16
	}
	F__pthread_cond_data uint64
} /* types.h:450:9 */

type Pthread_cond_t = X_pthread_cond /* types.h:457:3 */

// UNIX 98 Extension
type X_pthread_rwlock = struct {
	F__pthread_rwlock_readers  int32
	F__pthread_rwlock_type     uint16
	F__pthread_rwlock_magic    uint16
	F__pthread_rwlock_mutex    Pthread_mutex_t
	F__pthread_rwlock_readercv Pthread_cond_t
	F__pthread_rwlock_writercv Pthread_cond_t
} /* types.h:462:9 */

// UNIX 98 Extension
type Pthread_rwlock_t = X_pthread_rwlock /* types.h:469:3 */

// SUSV3
type Pthread_barrier_t = struct {
	F__pthread_barrier_count    uint32
	F__pthread_barrier_current  uint32
	F__pthread_barrier_cycle    uint64
	F__pthread_barrier_reserved uint64
	F__pthread_barrier_lock     Pthread_mutex_t
	F__pthread_barrier_cond     Pthread_cond_t
} /* types.h:481:3 */

type Pthread_spinlock_t = Pthread_mutex_t /* types.h:483:25 */

// attributes for threads, dynamically allocated by library
type X_pthread_attr = struct{ F__pthread_attrp uintptr } /* types.h:488:9 */

// attributes for threads, dynamically allocated by library
type Pthread_attr_t = X_pthread_attr /* types.h:490:3 */

// attributes for mutex, dynamically allocated by library
type X_pthread_mutexattr = struct{ F__pthread_mutexattrp uintptr } /* types.h:495:9 */

// attributes for mutex, dynamically allocated by library
type Pthread_mutexattr_t = X_pthread_mutexattr /* types.h:497:3 */

// attributes for cond, dynamically allocated by library
type X_pthread_condattr = struct{ F__pthread_condattrp uintptr } /* types.h:502:9 */

// attributes for cond, dynamically allocated by library
type Pthread_condattr_t = X_pthread_condattr /* types.h:504:3 */

// pthread_once
type X_once = struct{ F__pthread_once_pad [4]uint64 } /* types.h:509:9 */

// pthread_once
type Pthread_once_t = X_once /* types.h:511:3 */

// UNIX 98 Extensions
// attributes for rwlock, dynamically allocated by library
type X_pthread_rwlockattr = struct{ F__pthread_rwlockattrp uintptr } /* types.h:517:9 */

// UNIX 98 Extensions
// attributes for rwlock, dynamically allocated by library
type Pthread_rwlockattr_t = X_pthread_rwlockattr /* types.h:519:3 */

// SUSV3
// attributes for pthread_barrier_t, dynamically allocated by library
type Pthread_barrierattr_t = struct{ F__pthread_barrierattrp uintptr } /* types.h:527:3 */

type Dev_t = uint64 /* types.h:529:17 */ // expanded device type

type Nlink_t = uint32 /* types.h:532:16 */ // file link type
type Pid_t = int32    /* types.h:533:13 */ // size of something in bytes

type Ssize_t = int64 /* types.h:551:14 */ // size of something in bytes or -1

type Time_t = int64 /* types.h:559:15 */ // time of day in seconds

type Clock_t = int64 /* types.h:564:15 */ // relative time in a specified resolution

type Clockid_t = int32 /* types.h:569:13 */ // clock identifier type

type Timer_t = int32 /* types.h:574:13 */ // timer identifier type

// BEGIN CSTYLED
type Unchar = uint8  /* types.h:580:23 */
type Ushort = uint16 /* types.h:581:24 */
type Uint = uint32   /* types.h:582:22 */
type Ulong = uint64  /* types.h:583:23 */
// END CSTYLED

// The following is the value of type id_t to use to indicate the
// caller's current id.  See procset.h for the type idtype_t
// which defines which kind of id is being specified.

// The following value of type pfn_t is used to indicate
// invalid page frame number.

// BEGIN CSTYLED
type U_char = uint8                   /* types.h:650:23 */
type U_short = uint16                 /* types.h:651:24 */
type U_int = uint32                   /* types.h:652:22 */
type U_long = uint64                  /* types.h:653:23 */
type X_quad = struct{ Fval [2]int32 } /* types.h:654:9 */

type Quad_t = X_quad /* types.h:654:38 */ // used by UFS
type Quad = Quad_t   /* types.h:655:17 */ // used by UFS
// END CSTYLED

// Nested include for BSD/sockets source compatibility.
// (The select macros used to be defined here).
// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
//
// Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Implementation-private.  This header should not be included
// directly by an application.  The application should instead
// include <time.h> which includes this header conditionally
// depending on which feature test macros are defined. By default,
// this header is included by <time.h>.  X/Open and POSIX
// standards requirements result in this header being included
// by <time.h> only under a restricted set of conditions.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Time expressed in seconds and nanoseconds

type Timespec = struct {
	Ftv_sec  int64
	Ftv_nsec int64
} /* time_impl.h:57:9 */

// used by UFS
// END CSTYLED

// Nested include for BSD/sockets source compatibility.
// (The select macros used to be defined here).
// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
//
// Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Implementation-private.  This header should not be included
// directly by an application.  The application should instead
// include <time.h> which includes this header conditionally
// depending on which feature test macros are defined. By default,
// this header is included by <time.h>.  X/Open and POSIX
// standards requirements result in this header being included
// by <time.h> only under a restricted set of conditions.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Time expressed in seconds and nanoseconds

type Timespec_t = Timespec /* time_impl.h:60:3 */

type Timestruc_t = Timespec /* time_impl.h:81:25 */ // definition per SVr4

// The following has been left in for backward compatibility. Portable
// applications should not use the structure name timestruc.

// Timer specification
type Itimerspec = struct {
	Fit_interval struct {
		Ftv_sec  int64
		Ftv_nsec int64
	}
	Fit_value struct {
		Ftv_sec  int64
		Ftv_nsec int64
	}
} /* time_impl.h:95:9 */

// definition per SVr4

// The following has been left in for backward compatibility. Portable
// applications should not use the structure name timestruc.

// Timer specification
type Itimerspec_t = Itimerspec /* time_impl.h:98:3 */

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright (c) 1982, 1986, 1993 Regents of the University of California.
// All rights reserved.  The Berkeley software License Agreement
// specifies the terms and conditions for redistribution.

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2020 OmniOS Community Edition (OmniOSce) Association.

// Copyright (c) 2013, 2016 by Delphix. All rights reserved.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Structure returned by gettimeofday(2) system call,
// and used in other calls.

type Timeval = struct {
	Ftv_sec  int64
	Ftv_usec int64
} /* time.h:54:1 */

type Timezone = struct {
	Ftz_minuteswest int32
	Ftz_dsttime     int32
} /* time.h:86:1 */

// Needed for longlong_t type.  Placement of this due to <sys/types.h>
// including <sys/select.h> which relies on the presense of the itimerval
// structure.
// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// Operations on timevals.

// Names of the interval timers, and structure
// defining a timer setting.
// time and when system is running on
// behalf of the process.
// time profiling of multithreaded
// programs.

type Itimerval = struct {
	Fit_interval struct {
		Ftv_sec  int64
		Ftv_usec int64
	}
	Fit_value struct {
		Ftv_sec  int64
		Ftv_usec int64
	}
} /* time.h:209:1 */

//	Definitions for commonly used resolutions.

// Time expressed as a 64-bit nanosecond counter.
type Hrtime_t = int64 /* time.h:265:20 */

// The inclusion of <time.h> is historical and was added for
// backward compatibility in delta 1.2 when a number of definitions
// were moved out of <sys/time.h>.  More recently, the timespec and
// itimerspec structure definitions, along with the _CLOCK_*, CLOCK_*,
// _TIMER_*, and TIMER_* symbols were moved to <sys/time_impl.h>,
// which is now included by <time.h>.  This change was due to POSIX
// 1003.1b-1993 and X/Open UNIX 98 requirements.  For non-POSIX and
// non-X/Open applications, including this header will still make
// visible these definitions.
// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1988 AT&T
//	  All Rights Reserved

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2010 Nexenta Systems, Inc.  Al rights reserved.
// Copyright 2016 Joyent, Inc.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1988 AT&T
//	  All Rights Reserved

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
// Copyright 2014 PALO, Richard.
//
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// An application should not include this header directly.  Instead it
// should be included only through the inclusion of other Sun headers.
//
// The contents of this header is limited to identifiers specified in the
// C Standard.  Any new identifiers specified in future amendments to the
// C Standard must be placed in this header.  If these new identifiers
// are required to also be in the C++ Standard "std" namespace, then for
// anything other than macro definitions, corresponding "using" directives
// must also be added to <time.h.h>.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// This file and its contents are supplied under the terms of the
// Common Development and Distribution License ("CDDL"), version 1.0.
// You may only use this file in accordance with the terms of version
// 1.0 of the CDDL.
//
// A full copy of the text of the CDDL should have accompanied this
// source.  A copy of the CDDL is also available via the Internet at
// http://www.illumos.org/license/CDDL.

// Copyright 2014-2016 PALO, Richard.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// POSIX.1-2008 requires that the NULL macro be cast to type void *.

type Tm = struct {
	Ftm_sec   int32
	Ftm_min   int32
	Ftm_hour  int32
	Ftm_mday  int32
	Ftm_mon   int32
	Ftm_year  int32
	Ftm_wday  int32
	Ftm_yday  int32
	Ftm_isdst int32
} /* time_iso.h:80:1 */

// Neither X/Open nor POSIX allow the inclusion of <signal.h> for the
// definition of the sigevent structure.  Both require the inclusion
// of <signal.h> and <time.h> when using the timer_create() function.
// However, X/Open also specifies that the sigevent structure be defined
// in <time.h> as described in the header <signal.h>.  This prevents
// compiler warnings for applications that only include <time.h> and not
// also <signal.h>.  The sigval union and the sigevent structure is
// therefore defined both here and in <sys/siginfo.h> which gets included
// via inclusion of <signal.h>.
type Sigval = struct {
	F__ccgo_pad1 [0]uint64
	Fsival_int   int32
	F__ccgo_pad2 [4]byte
} /* time.h:125:1 */

type Sigevent = struct {
	Fsigev_notify int32
	Fsigev_signo  int32
	Fsigev_value  struct {
		F__ccgo_pad1 [0]uint64
		Fsival_int   int32
		F__ccgo_pad2 [4]byte
	}
	Fsigev_notify_function   uintptr
	Fsigev_notify_attributes uintptr
	F__sigev_pad2            int32
	F__ccgo_pad1             [4]byte
} /* time.h:133:1 */

type Locale_t = uintptr /* time.h:292:24 */

// The inclusion of <sys/select.h> is needed for the FD_CLR,
// FD_ISSET, FD_SET, and FD_SETSIZE macros as well as the
// select() prototype defined in the XOpen specifications
// beginning with XSH4v2.  Placement required after definition
// for itimerval.
// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
//
// Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

// The sigset_t type is defined in <sys/signal.h> and duplicated
// in <sys/ucontext.h> as a result of XPG4v2 requirements. XPG6
// now allows the visibility of signal.h in this header, however
// an order of inclusion problem occurs as a result of inclusion
// of <sys/select.h> in <signal.h> under certain conditions.
// Rather than include <sys/signal.h> here, we've duplicated
// the sigset_t type instead. This type is required for the XPG6
// introduced pselect() function also declared in this header.
type Sigset_t = struct{ F__sigbits [4]uint32 } /* select.h:76:3 */

// Select uses bit masks of file descriptors in longs.
// These macros manipulate such bit fields.
// FD_SETSIZE may be defined by the user, but the default here
// should be >= RLIM_FD_MAX.

type Fd_mask = int64  /* select.h:92:14 */
type Fds_mask = int64 /* select.h:94:14 */

//  The value of _NBBY needs to be consistant with the value
//  of NBBY in <sys/param.h>.

type Fd_set1 = struct{ Ffds_bits [1024]int64 } /* select.h:120:9 */

//  The value of _NBBY needs to be consistant with the value
//  of NBBY in <sys/param.h>.

type Fd_set = Fd_set1 /* select.h:125:3 */ // Clearance

type X_tsol_binary_level_lrange = struct {
	Flower_bound uintptr
	Fupper_bound uintptr
} /* label.h:58:9 */

// Clearance

type M_range_t = X_tsol_binary_level_lrange /* label.h:61:3 */

type Blrange_t = M_range_t /* label.h:63:19 */

type Tsol_mlp_s = struct {
	Fmlp_ipp        uint8
	F__ccgo_pad1    [1]byte
	Fmlp_port       uint16
	Fmlp_port_upper uint16
} /* label.h:65:9 */

type Tsol_mlp_t = Tsol_mlp_s /* label.h:69:3 */

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2011 Nexenta Systems, Inc. All rights reserved.
// Copyright 2015, Joyent, Inc.
// Copyright 2020 OmniOS Community Edition (OmniOSce) Association.
// Copyright (c) 1982, 1986 Regents of the University of California.
// All rights reserved.
//
// Redistribution and use in source and binary forms are permitted
// provided that this notice is preserved and that due credit is given
// to the University of California at Berkeley. The name of the University
// may not be used to endorse or promote products derived from this
// software without specific prior written permission. This software
// is provided ``as is'' without express or implied warranty.

// Constants and structures defined by the internet system,
// according to following documents
//
// Internet ASSIGNED NUMBERS (RFC1700) and its successors:
//	http://www.iana.org/assignments/protocol-numbers
//	http://www.iana.org/assignments/port-numbers
// Basic Socket Interface Extensions for IPv6 (RFC2133 and its successors)
//

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Portions of this source code were derived from Berkeley 4.3 BSD
// under license from the Regents of the University of California.

type Sa_family_t = uint16 /* socket_impl.h:43:18 */

// Structure used by kernel to store most
// addresses.
type Sockaddr = struct {
	Fsa_family uint16
	Fsa_data   [14]int8
} /* socket_impl.h:50:1 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

// Definitions for UNIX IPC domain.
type Sockaddr_un = struct {
	Fsun_family uint16
	Fsun_path   [108]int8
} /* un.h:53:1 */

// Copyright 1993-2003 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.

// from UCB 8.1 (Berkeley) 6/10/93

// A Link-Level Sockaddr may specify the interface in one of two
// ways: either by means of a system-provided index number (computed
// anew and possibly differently on every reboot), or by a human-readable
// string such as "il0" (for managerial convenience).
//
// Census taking actions, such as something akin to SIOCGCONF would return
// both the index and the human name.
//
// High volume transactions (such as giving a link-level ``from'' address
// in a recvfrom or recvmsg call) may be likely only to provide the indexed
// form, (which requires fewer copy operations and less space).
//
// The form and interpretation  of the link-level address is purely a matter
// of convention between the device driver and its consumers; however, it is
// expected that all drivers for an interface of a given if_type will agree.

// Structure of a Link-Level sockaddr:
type Sockaddr_dl = struct {
	Fsdl_family uint16
	Fsdl_index  uint16
	Fsdl_type   uint8
	Fsdl_nlen   uint8
	Fsdl_alen   uint8
	Fsdl_slen   uint8
	Fsdl_data   [244]int8
} /* if_dl.h:68:1 */

// sockaddr_storage:
// Common superset of at least AF_INET, AF_INET6 and AF_LINK sockaddr
// structures. Has sufficient size and alignment for those sockaddrs.

// Desired maximum size, alignment size and related types.

// To represent desired sockaddr max alignment for platform, a
// type is chosen which may depend on implementation platform architecture.
// Type chosen based on alignment size restrictions from <sys/isa_defs.h>.
// We desire to force up to (but no more than) 64-bit (8 byte) alignment,
// on platforms where it is possible to do so. (e.g not possible on ia32).
// For all currently supported platforms by our implementation
// in <sys/isa_defs.h>, (i.e. sparc, sparcv9, ia32, ia64)
// type "double" is suitable for that intent.
//
// Note: Type "double" is chosen over the more obvious integer type int64_t.
//
//	int64_t is not a valid type for strict ANSI/ISO C compilation on ILP32.
type Sockaddr_maxalign_t = float64 /* socket_impl.h:85:17 */

// Definitions used for sockaddr_storage structure paddings design.

type Sockaddr_storage = struct {
	Fss_family uint16
	F_ss_pad1  [6]int8
	F_ss_align float64
	F_ss_pad2  [240]int8
} /* socket_impl.h:96:1 */

// To be compatible with the Linux interfaces used, this structure is
// placed in socket_impl.h so that an include for <sys/socket.h> will
// pickup this structure. This structure is for use with PF_PACKET
// sockets.
type Sockaddr_ll = struct {
	Fsll_family   uint16
	Fsll_protocol uint16
	Fsll_ifindex  int32
	Fsll_hatype   uint16
	Fsll_pkttype  uint8
	Fsll_halen    uint8
	Fsll_addr     [8]uint8
} /* socket_impl.h:111:1 */

// The socklen definitions are reproduced here from sys/socket.h so as to
// not introduce that namespace into existing users of netinet/in.h.
type Socklen_t = uint32 /* in.h:57:18 */

type Psocklen_t = uintptr /* in.h:63:15 */

// Symbols such as htonl() are required to be exposed through this file,
// per XNS Issue 5. This is achieved by inclusion of <sys/byteorder.h>
// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2016 Joyent, Inc.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// macros for conversion between host and (internet) network byte order

type In_port_t = uint16 /* byteorder.h:74:18 */

type In_addr_t = uint32 /* byteorder.h:79:18 */

// Macros to reverse byte order

// Macros to convert from a specific byte order to/from native byte order

// Macros to read unaligned values from a specific byte order to
// native byte order

// Macros to write unaligned values from native byte order to a specific byte
// order.

// Note: IPv4 address data structures usage conventions.
// The "in_addr_t" type below (required by Unix standards)
// is NOT a typedef of "struct in_addr" and violates the usual
// conventions where "struct <name>" and <name>_t are corresponding
// typedefs.
// To minimize confusion, kernel data structures/usage prefers use
// of "ipaddr_t" as atomic uint32_t type and avoid using "in_addr_t"
// The user level APIs continue to follow the historic popular
// practice of using "struct in_addr".

type Ipaddr_t = uint32 /* in.h:99:18 */

type In6_addr = struct {
	F_S6_un struct {
		F__ccgo_pad1 [0]uint32
		F_S6_u8      [16]uint8
	}
} /* in.h:104:1 */

type In6_addr_t = In6_addr /* in.h:137:25 */

// Protocols
//
// Some of these constant names are copied for the DTrace IP provider in
// usr/src/lib/libdtrace/common/{ip.d.in, ip.sed.in}, which should be kept
// in sync.
// Transmission Protocol

// Port/socket numbers: network standard functions
//
// Entries should exist here for each port number compiled into an ON
// component, such as snoop.

// Port/socket numbers: host specific functions

// Internet Key Exchange (IKE) ports

// UNIX TCP sockets

// UNIX UDP sockets

// DHCPv6 UDP ports

// Ports < IPPORT_RESERVED are reserved for
// privileged processes (e.g. root).
// Ports > IPPORT_USERRESERVED are reserved
// for servers, not necessarily privileged.

// Link numbers

// IPv4 Internet address
//	This definition contains obsolete fields for compatibility
//	with SunOS 3.x and 4.2bsd.  The presence of subnets renders
//	divisions into fixed fields misleading at best.  New code
//	should use only the s_addr field.

type In_addr = struct {
	FS_un struct {
		F__ccgo_pad1 [0]uint32
		FS_un_b      struct {
			Fs_b1 uint8
			Fs_b2 uint8
			Fs_b3 uint8
			Fs_b4 uint8
		}
	}
} /* in.h:301:1 */

// Definitions of bits in internet address integers.
// On subnets, the decomposition of addresses to host and net parts
// is done according to subnet mask, not the masks here.
//
// Note that with the introduction of CIDR, IN_CLASSA, IN_CLASSB,
// IN_CLASSC, IN_CLASSD and IN_CLASSE macros have become "de-facto
// obsolete". IN_MULTICAST macro should be used to test if a address
// is a multicast address.

// We have removed CLASS E checks from the kernel
// But we preserve these defines for userland in order
// to avoid compile  breakage of some 3rd party piece of software

// Scoped IPv4 prefixes (in host byte-order)

// RFC 3927 IPv4 link local address (i in host byte-order)

// Well known 6to4 Relay Router Anycast address defined in RFC 3068

// Define a macro to stuff the loopback address into an Internet address

// IPv4 Socket address.
type Sockaddr_in = struct {
	Fsin_family uint16
	Fsin_port   uint16
	Fsin_addr   struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
	Fsin_zero [8]int8
} /* in.h:409:1 */

// IPv6 socket address.
type Sockaddr_in6 = struct {
	Fsin6_family   uint16
	Fsin6_port     uint16
	Fsin6_flowinfo uint32
	Fsin6_addr     struct {
		F_S6_un struct {
			F__ccgo_pad1 [0]uint32
			F_S6_u8      [16]uint8
		}
	}
	Fsin6_scope_id uint32
	F__sin6_src_id uint32
} /* in.h:424:1 */

// Macros for accessing the traffic class and flow label fields from
// sin6_flowinfo.
// These are designed to be applied to a 32-bit value.

// masks

// Note: Macros IN6ADDR_ANY_INIT and IN6ADDR_LOOPBACK_INIT are for
// use as RHS of Static initializers of "struct in6_addr" (or in6_addr_t)
// only. They need to be different for User/Kernel versions because union
// component data structure is defined differently (it is identical at
// binary representation level).
//
// const struct in6_addr IN6ADDR_ANY_INIT;
// const struct in6_addr IN6ADDR_LOOPBACK_INIT;

// RFC 2553 specifies the following macros. Their type is defined
// as "int" in the RFC but they only have boolean significance
// (zero or non-zero). For the purposes of our comment notation,
// we assume a hypothetical type "bool" defined as follows to
// write the prototypes assumed for macros in our comments better.
//
// typedef int bool;

// IN6 macros used to test for special IPv6 addresses
// (Mostly from spec)
//
// bool  IN6_IS_ADDR_UNSPECIFIED (const struct in6_addr *);
// bool  IN6_IS_ADDR_LOOPBACK    (const struct in6_addr *);
// bool  IN6_IS_ADDR_MULTICAST   (const struct in6_addr *);
// bool  IN6_IS_ADDR_LINKLOCAL   (const struct in6_addr *);
// bool  IN6_IS_ADDR_SITELOCAL   (const struct in6_addr *);
// bool  IN6_IS_ADDR_V4MAPPED    (const struct in6_addr *);
// bool  IN6_IS_ADDR_V4MAPPED_ANY(const struct in6_addr *); -- Not from RFC2553
// bool  IN6_IS_ADDR_V4COMPAT    (const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_RESERVED (const struct in6_addr *); -- Not from RFC2553
// bool  IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_ORGLOCAL (const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_GLOBAL   (const struct in6_addr *);
// bool  IN6_IS_ADDR_6TO4	 (const struct in6_addr *); -- Not from RFC2553
// bool  IN6_ARE_6TO4_PREFIX_EQUAL(const struct in6_addr *,
//	     const struct in6_addr *);			    -- Not from RFC2553
// bool  IN6_IS_ADDR_LINKSCOPE	 (const struct in6addr  *); -- Not from RFC2553

// IN6_IS_ADDR_V4MAPPED - A IPv4 mapped INADDR_ANY
// Note: This macro is currently NOT defined in RFC2553 specification
// and not a standard macro that portable applications should use.

// Exclude loopback and unspecified address

// Note:
// IN6_IS_ADDR_MC_RESERVED macro is currently NOT defined in RFC2553
// specification and not a standard macro that portable applications
// should use.

// The IN6_IS_ADDR_MC_SOLICITEDNODE macro is not defined in any standard or
// RFC, and shouldn't be used by portable applications.  It is used to see
// if an address is a solicited-node multicast address, which is prefixed
// with ff02:0:0:0:0:1:ff00::/104.

// Macros to a) test for 6to4 IPv6 address, and b) to test if two
// 6to4 addresses have the same /48 prefix, and, hence, are from the
// same 6to4 site.

// IN6_IS_ADDR_LINKSCOPE
// Identifies an address as being either link-local, link-local multicast or
// node-local multicast.  All types of addresses are considered to be unique
// within the scope of a given link.

// Useful utility macros for operations with IPv6 addresses
// Note: These macros are NOT defined in the RFC2553 or any other
// standard specification and are not standard macros that portable
// applications should use.

// IN6_V4MAPPED_TO_INADDR
// IN6_V4MAPPED_TO_IPADDR
//	Assign a IPv4-Mapped IPv6 address to an IPv4 address.
//	Note: These macros are NOT defined in RFC2553 or any other standard
//	specification and are not macros that portable applications should
//	use.
//
// void IN6_V4MAPPED_TO_INADDR(const in6_addr_t *v6, struct in_addr *v4);
// void IN6_V4MAPPED_TO_IPADDR(const in6_addr_t *v6, ipaddr_t v4);
//

// IN6_INADDR_TO_V4MAPPED
// IN6_IPADDR_TO_V4MAPPED
//	Assign a IPv4 address address to an IPv6 address as a IPv4-mapped
//	address.
//	Note: These macros are NOT defined in RFC2553 or any other standard
//	specification and are not macros that portable applications should
//	use.
//
// void IN6_INADDR_TO_V4MAPPED(const struct in_addr *v4, in6_addr_t *v6);
// void IN6_IPADDR_TO_V4MAPPED(const ipaddr_t v4, in6_addr_t *v6);
//

// IN6_6TO4_TO_V4ADDR
//	Extract the embedded IPv4 address from the prefix to a 6to4 IPv6
//      address.
//	Note: This macro is NOT defined in RFC2553 or any other standard
//	specification and is not a macro that portable applications should
//	use.
//	Note: we don't use the IPADDR form of the macro because we need
//	to do a bytewise copy; the V4ADDR in the 6to4 address is not
//	32-bit aligned.
//
// void IN6_6TO4_TO_V4ADDR(const in6_addr_t *v6, struct in_addr *v4);
//

// IN6_V4ADDR_TO_6TO4
//	Given an IPv4 address and an IPv6 address for output, a 6to4 address
//	will be created from the IPv4 Address.
//	Note:  This method for creating 6to4 addresses is not standardized
//	outside of Solaris.  The newly created 6to4 address will be of the form
//	2002:<V4ADDR>:<SUBNETID>::<HOSTID>, where SUBNETID will equal 0 and
//	HOSTID will equal 1.
//
// void IN6_V4ADDR_TO_6TO4(const struct in_addr *v4, in6_addr_t *v6)
//

// IN6_ARE_ADDR_EQUAL (defined in RFC2292)
//	 Compares if IPv6 addresses are equal.
// Note: Compares in order of high likelyhood of a miss so we minimize
// compares. (Current heuristic order, compare in reverse order of
// uint32_t units)
//
// bool  IN6_ARE_ADDR_EQUAL(const struct in6_addr *,
//			    const struct in6_addr *);

// IN6_ARE_PREFIXEDADDR_EQUAL (not defined in RFCs)
//	Compares if prefixed parts of IPv6 addresses are equal.
//
// uint32_t IN6_MASK_FROM_PREFIX(int, int);
// bool     IN6_ARE_PREFIXEDADDR_EQUAL(const struct in6_addr *,
//				       const struct in6_addr *,
//				       int);

// Options for use with [gs]etsockopt at the IP level.
//
// Note: Some of the IP_ namespace has conflict with and
// and is exposed through <xti.h>. (It also requires exposing
// options not implemented). The options with potential
// for conflicts use #ifndef guards.

// IP_PKTINFO and IP_RECVPKTINFO have same value. Size of argument passed in
// is used to differentiate b/w the two.

// Different preferences that can be requested from IPSEC protocols.
// This can be used with the setsockopt() call to set per socket security
// options. When the application uses per-socket API, we will reflect
// the request on both outbound and inbound packets.

type Ipsec_req = struct {
	Fipsr_ah_req         uint32
	Fipsr_esp_req        uint32
	Fipsr_self_encap_req uint32
	Fipsr_auth_alg       uint8
	Fipsr_esp_alg        uint8
	Fipsr_esp_auth_alg   uint8
	F__ccgo_pad1         [1]byte
} /* in.h:950:9 */

// Macros for accessing the traffic class and flow label fields from
// sin6_flowinfo.
// These are designed to be applied to a 32-bit value.

// masks

// Note: Macros IN6ADDR_ANY_INIT and IN6ADDR_LOOPBACK_INIT are for
// use as RHS of Static initializers of "struct in6_addr" (or in6_addr_t)
// only. They need to be different for User/Kernel versions because union
// component data structure is defined differently (it is identical at
// binary representation level).
//
// const struct in6_addr IN6ADDR_ANY_INIT;
// const struct in6_addr IN6ADDR_LOOPBACK_INIT;

// RFC 2553 specifies the following macros. Their type is defined
// as "int" in the RFC but they only have boolean significance
// (zero or non-zero). For the purposes of our comment notation,
// we assume a hypothetical type "bool" defined as follows to
// write the prototypes assumed for macros in our comments better.
//
// typedef int bool;

// IN6 macros used to test for special IPv6 addresses
// (Mostly from spec)
//
// bool  IN6_IS_ADDR_UNSPECIFIED (const struct in6_addr *);
// bool  IN6_IS_ADDR_LOOPBACK    (const struct in6_addr *);
// bool  IN6_IS_ADDR_MULTICAST   (const struct in6_addr *);
// bool  IN6_IS_ADDR_LINKLOCAL   (const struct in6_addr *);
// bool  IN6_IS_ADDR_SITELOCAL   (const struct in6_addr *);
// bool  IN6_IS_ADDR_V4MAPPED    (const struct in6_addr *);
// bool  IN6_IS_ADDR_V4MAPPED_ANY(const struct in6_addr *); -- Not from RFC2553
// bool  IN6_IS_ADDR_V4COMPAT    (const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_RESERVED (const struct in6_addr *); -- Not from RFC2553
// bool  IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_LINKLOCAL(const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_SITELOCAL(const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_ORGLOCAL (const struct in6_addr *);
// bool  IN6_IS_ADDR_MC_GLOBAL   (const struct in6_addr *);
// bool  IN6_IS_ADDR_6TO4	 (const struct in6_addr *); -- Not from RFC2553
// bool  IN6_ARE_6TO4_PREFIX_EQUAL(const struct in6_addr *,
//	     const struct in6_addr *);			    -- Not from RFC2553
// bool  IN6_IS_ADDR_LINKSCOPE	 (const struct in6addr  *); -- Not from RFC2553

// IN6_IS_ADDR_V4MAPPED - A IPv4 mapped INADDR_ANY
// Note: This macro is currently NOT defined in RFC2553 specification
// and not a standard macro that portable applications should use.

// Exclude loopback and unspecified address

// Note:
// IN6_IS_ADDR_MC_RESERVED macro is currently NOT defined in RFC2553
// specification and not a standard macro that portable applications
// should use.

// The IN6_IS_ADDR_MC_SOLICITEDNODE macro is not defined in any standard or
// RFC, and shouldn't be used by portable applications.  It is used to see
// if an address is a solicited-node multicast address, which is prefixed
// with ff02:0:0:0:0:1:ff00::/104.

// Macros to a) test for 6to4 IPv6 address, and b) to test if two
// 6to4 addresses have the same /48 prefix, and, hence, are from the
// same 6to4 site.

// IN6_IS_ADDR_LINKSCOPE
// Identifies an address as being either link-local, link-local multicast or
// node-local multicast.  All types of addresses are considered to be unique
// within the scope of a given link.

// Useful utility macros for operations with IPv6 addresses
// Note: These macros are NOT defined in the RFC2553 or any other
// standard specification and are not standard macros that portable
// applications should use.

// IN6_V4MAPPED_TO_INADDR
// IN6_V4MAPPED_TO_IPADDR
//	Assign a IPv4-Mapped IPv6 address to an IPv4 address.
//	Note: These macros are NOT defined in RFC2553 or any other standard
//	specification and are not macros that portable applications should
//	use.
//
// void IN6_V4MAPPED_TO_INADDR(const in6_addr_t *v6, struct in_addr *v4);
// void IN6_V4MAPPED_TO_IPADDR(const in6_addr_t *v6, ipaddr_t v4);
//

// IN6_INADDR_TO_V4MAPPED
// IN6_IPADDR_TO_V4MAPPED
//	Assign a IPv4 address address to an IPv6 address as a IPv4-mapped
//	address.
//	Note: These macros are NOT defined in RFC2553 or any other standard
//	specification and are not macros that portable applications should
//	use.
//
// void IN6_INADDR_TO_V4MAPPED(const struct in_addr *v4, in6_addr_t *v6);
// void IN6_IPADDR_TO_V4MAPPED(const ipaddr_t v4, in6_addr_t *v6);
//

// IN6_6TO4_TO_V4ADDR
//	Extract the embedded IPv4 address from the prefix to a 6to4 IPv6
//      address.
//	Note: This macro is NOT defined in RFC2553 or any other standard
//	specification and is not a macro that portable applications should
//	use.
//	Note: we don't use the IPADDR form of the macro because we need
//	to do a bytewise copy; the V4ADDR in the 6to4 address is not
//	32-bit aligned.
//
// void IN6_6TO4_TO_V4ADDR(const in6_addr_t *v6, struct in_addr *v4);
//

// IN6_V4ADDR_TO_6TO4
//	Given an IPv4 address and an IPv6 address for output, a 6to4 address
//	will be created from the IPv4 Address.
//	Note:  This method for creating 6to4 addresses is not standardized
//	outside of Solaris.  The newly created 6to4 address will be of the form
//	2002:<V4ADDR>:<SUBNETID>::<HOSTID>, where SUBNETID will equal 0 and
//	HOSTID will equal 1.
//
// void IN6_V4ADDR_TO_6TO4(const struct in_addr *v4, in6_addr_t *v6)
//

// IN6_ARE_ADDR_EQUAL (defined in RFC2292)
//	 Compares if IPv6 addresses are equal.
// Note: Compares in order of high likelyhood of a miss so we minimize
// compares. (Current heuristic order, compare in reverse order of
// uint32_t units)
//
// bool  IN6_ARE_ADDR_EQUAL(const struct in6_addr *,
//			    const struct in6_addr *);

// IN6_ARE_PREFIXEDADDR_EQUAL (not defined in RFCs)
//	Compares if prefixed parts of IPv6 addresses are equal.
//
// uint32_t IN6_MASK_FROM_PREFIX(int, int);
// bool     IN6_ARE_PREFIXEDADDR_EQUAL(const struct in6_addr *,
//				       const struct in6_addr *,
//				       int);

// Options for use with [gs]etsockopt at the IP level.
//
// Note: Some of the IP_ namespace has conflict with and
// and is exposed through <xti.h>. (It also requires exposing
// options not implemented). The options with potential
// for conflicts use #ifndef guards.

// IP_PKTINFO and IP_RECVPKTINFO have same value. Size of argument passed in
// is used to differentiate b/w the two.

// Different preferences that can be requested from IPSEC protocols.
// This can be used with the setsockopt() call to set per socket security
// options. When the application uses per-socket API, we will reflect
// the request on both outbound and inbound packets.

type Ipsec_req_t = Ipsec_req /* in.h:957:3 */

// MCAST_* options are protocol-independent.  The actual definitions
// are with the v6 options below; this comment is here to note the
// namespace usage.
//
// #define	MCAST_JOIN_GROUP	0x29
// #define	MCAST_LEAVE_GROUP	0x2a
// #define	MCAST_BLOCK_SOURCE	0x2b
// #define	MCAST_UNBLOCK_SOURCE	0x2c
// #define	MCAST_JOIN_SOURCE_GROUP	0x2d
// #define	MCAST_LEAVE_SOURCE_GROUP 0x2e

// SunOS private (potentially not portable) IP_ option names
// can be reused		0x44

// Option values and names (when !_XPG5) shared with <xti_inet.h>

// The following option values are reserved by <xti_inet.h>
//
// T_IP_OPTIONS	0x107	 -  IP per-packet options
// T_IP_TOS	0x108	 -  IP per packet type of service

// Default value constants for multicast attributes controlled by
// IP*_MULTICAST_LOOP and IP*_MULTICAST_{TTL,HOPS} options.

// Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
type Ip_mreq = struct {
	Fimr_multiaddr struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
	Fimr_interface struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
} /* in.h:1015:1 */

// Argument structure for IP_BLOCK_SOURCE, IP_UNBLOCK_SOURCE,
// IP_ADD_SOURCE_MEMBERSHIP, and IP_DROP_SOURCE_MEMBERSHIP.
type Ip_mreq_source = struct {
	Fimr_multiaddr struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
	Fimr_sourceaddr struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
	Fimr_interface struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
} /* in.h:1024:1 */

// Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP on
// IPv6 addresses.
type Ipv6_mreq = struct {
	Fipv6mr_multiaddr struct {
		F_S6_un struct {
			F__ccgo_pad1 [0]uint32
			F_S6_u8      [16]uint8
		}
	}
	Fipv6mr_interface uint32
} /* in.h:1034:1 */

// Use #pragma pack() construct to force 32-bit alignment on amd64.
// This is needed to keep the structure size and offsets consistent
// between a 32-bit app and the 64-bit amd64 kernel in structures
// where 64-bit alignment would create gaps (in this case, structures
// which have a uint32_t followed by a struct sockaddr_storage).

// Argument structure for MCAST_JOIN_GROUP and MCAST_LEAVE_GROUP.
type Group_req = struct {
	Fgr_interface uint32
	F__ccgo_pad1  [4]byte
	Fgr_group     struct {
		Fss_family uint16
		F_ss_pad1  [6]int8
		F_ss_align float64
		F_ss_pad2  [240]int8
	}
} /* in.h:1053:1 */

// Argument structure for MCAST_BLOCK_SOURCE, MCAST_UNBLOCK_SOURCE,
// MCAST_JOIN_SOURCE_GROUP, MCAST_LEAVE_SOURCE_GROUP.
type Group_source_req = struct {
	Fgsr_interface uint32
	F__ccgo_pad1   [4]byte
	Fgsr_group     struct {
		Fss_family uint16
		F_ss_pad1  [6]int8
		F_ss_align float64
		F_ss_pad2  [240]int8
	}
	Fgsr_source struct {
		Fss_family uint16
		F_ss_pad1  [6]int8
		F_ss_align float64
		F_ss_pad2  [240]int8
	}
} /* in.h:1062:1 */

// Argument for SIOC[GS]MSFILTER ioctls
type Group_filter = struct {
	Fgf_interface uint32
	F__ccgo_pad1  [4]byte
	Fgf_group     struct {
		Fss_family uint16
		F_ss_pad1  [6]int8
		F_ss_align float64
		F_ss_pad2  [240]int8
	}
	Fgf_fmode  uint32
	Fgf_numsrc uint32
	Fgf_slist  [1]struct {
		Fss_family uint16
		F_ss_pad1  [6]int8
		F_ss_align float64
		F_ss_pad2  [240]int8
	}
} /* in.h:1071:1 */

// Argument for SIOC[GS]IPMSFILTER ioctls (IPv4-specific)
type Ip_msfilter = struct {
	Fimsf_multiaddr struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
	Fimsf_interface struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
	Fimsf_fmode  uint32
	Fimsf_numsrc uint32
	Fimsf_slist  [1]struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
} /* in.h:1090:1 */

// Definitions needed for [gs]etsourcefilter(), [gs]etipv4sourcefilter()

// Argument struct for IP_PKTINFO option
type In_pktinfo = struct {
	Fipi_ifindex  uint32
	Fipi_spec_dst struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
	Fipi_addr struct {
		FS_un struct {
			F__ccgo_pad1 [0]uint32
			FS_un_b      struct {
				Fs_b1 uint8
				Fs_b2 uint8
				Fs_b3 uint8
				Fs_b4 uint8
			}
		}
	}
} /* in.h:1127:9 */

// Definitions needed for [gs]etsourcefilter(), [gs]etipv4sourcefilter()

// Argument struct for IP_PKTINFO option
type In_pktinfo_t = In_pktinfo /* in.h:1131:3 */

// Argument struct for IPV6_PKTINFO option
type In6_pktinfo = struct {
	Fipi6_addr struct {
		F_S6_un struct {
			F__ccgo_pad1 [0]uint32
			F_S6_u8      [16]uint8
		}
	}
	Fipi6_ifindex uint32
} /* in.h:1136:1 */

// Argument struct for IPV6_MTUINFO option
type Ip6_mtuinfo = struct {
	Fip6m_addr struct {
		Fsin6_family   uint16
		Fsin6_port     uint16
		Fsin6_flowinfo uint32
		Fsin6_addr     struct {
			F_S6_un struct {
				F__ccgo_pad1 [0]uint32
				F_S6_u8      [16]uint8
			}
		}
		Fsin6_scope_id uint32
		F__sin6_src_id uint32
	}
	Fip6m_mtu uint32
} /* in.h:1144:1 */

// Argument structure for IP_ADD_PROXY_ADDR.
// Note that this is an unstable, experimental interface. It may change
// later. Don't use it unless you know what it is.
type In_prefix_t = struct {
	Fin_prefix_addr In_addr
	Fin_prefix_len  uint32
} /* in.h:1183:3 */

// NOTE
//
// The contents of this file are private to the implementation of
// illumos and are subject to change at any time without notice.
// Applications and drivers using these interfaces may fail to
// run on future releases.

// Available both in kernel and for user space

// zone id restrictions and special ids.
// See 'maxzones' for run-time zone limit.
//
// The current 8k value for MAX_ZONES was originally derived from the virtual
// interface limit in IP when "shared-stack" was the only supported networking
// for zones. The virtual interface limit is the number of addresses allowed
// on an interface (see MAX_ADDRS_PER_IF). Even with exclusive stacks, an 8k
// zone limit is still a reasonable choice at this time, given other limits
// within the kernel. Since we only support 8192 zones (which includes GZ),
// there is no point in allowing MAX_ZONEID > 8k.

// Special zoneid_t token to refer to all zones.

// system call subcodes

// zone attributes
//
// Note that values up to ZONE_ATTR_HOSTID are baked into things like Solaris
// 10 which can be run under the s10 brand; don't renumber or change them. Ones
// which are no longer used are commented out.
// #define	ZONE_ATTR_PHYS_MCAP	12

// illumos extensions

// OmniOS/SmartOS extensions

// Start of the brand-specific attribute namespace

// Exit values that may be returned by scripts or programs invoked by various
// zone commands.
//
// These are defined as:
//
//	ZONE_SUBPROC_OK
//	===============
//	The subprocess completed successfully.
//
//	ZONE_SUBPROC_USAGE
//	==================
//	The subprocess failed with a usage message, or a usage message should
//	be output in its behalf.
//
//	ZONE_SUBPROC_NOTCOMPLETE
//	========================
//	The subprocess did not complete, but the actions performed by the
//	subprocess require no recovery actions by the user.
//
//	For example, if the subprocess were called by "zoneadm install," the
//	installation of the zone did not succeed but the user need not perform
//	a "zoneadm uninstall" before attempting another install.
//
//	ZONE_SUBPROC_FATAL
//	==================
//	The subprocess failed in a fatal manner, usually one that will require
//	some type of recovery action by the user.
//
//	For example, if the subprocess were called by "zoneadm install," the
//	installation of the zone did not succeed and the user will need to
//	perform a "zoneadm uninstall" before another install attempt is
//	possible.
//
//	The non-success exit values are large to avoid accidental collision
//	with values used internally by some commands (e.g. "Z_ERR" and
//	"Z_USAGE" as used by zoneadm.)

type Zone_def = struct {
	Fzone_name      uintptr
	Fzone_root      uintptr
	Fzone_privs     uintptr
	Fzone_privssz   uint64
	Frctlbuf        uintptr
	Frctlbufsz      uint64
	Fextended_error uintptr
	Fzfsbuf         uintptr
	Fzfsbufsz       uint64
	Fmatch          int32
	Fdoi            uint32
	Flabel          uintptr
	Fflags          int32
	Fzoneid         int32
} /* zone.h:245:3 */

// extended error information

// zone_status values
//
// You must modify zone_status_names in mdb(1)'s genunix module
// (genunix/zone.c) when you modify this enum.
type Zone_status_t = uint32 /* zone.h:270:3 */

// Valid commands which may be issued by zoneadm to zoneadmd.  The kernel also
// communicates with zoneadmd, but only uses Z_REBOOT and Z_HALT.
type Zone_cmd_t = uint32 /* zone.h:281:3 */

// The structure of a request to zoneadmd.
type Zone_cmd_arg = struct {
	Funiqid  uint64
	Fcmd     uint32
	Fstatus  int32
	Fdebug   uint32
	Flocale  [1024]int8
	Fbootbuf [256]int8
	Fpad     int32
} /* zone.h:286:9 */

// The structure of a request to zoneadmd.
type Zone_cmd_arg_t = Zone_cmd_arg /* zone.h:295:3 */

// Structure of zoneadmd's response to a request.  A NULL return value means
// the caller should attempt to restart zoneadmd and retry.
type Zone_cmd_rval = struct {
	Frval        int32
	Ferrbuf      [1]int8
	F__ccgo_pad1 [3]byte
} /* zone.h:301:9 */

// Structure of zoneadmd's response to a request.  A NULL return value means
// the caller should attempt to restart zoneadmd and retry.
type Zone_cmd_rval_t = Zone_cmd_rval /* zone.h:304:3 */

// The zone support infrastructure uses the zone name as a component
// of unix domain (AF_UNIX) sockets, which are limited to 108 characters
// in length, so ZONENAME_MAX is limited by that.

// Extended Regular expression (see regex(7)) which matches all valid zone
// names.

// Where the zones support infrastructure places temporary files.

// The path to the door used by clients to communicate with zoneadmd.

// zone_flags
// Threads that read or write the following flag must hold zone_lock.

// The following threads are set when the zone is created and never changed.
// Threads that test for these flags don't have to hold zone_lock.

// zone_create flags

// zone network properties

type Zone_net_data = struct {
	Fzn_type     int32
	Fzn_len      int32
	Fzn_linkid   uint32
	Fzn_val      [1]uint8
	F__ccgo_pad1 [3]byte
} /* zone.h:357:9 */

// The zone support infrastructure uses the zone name as a component
// of unix domain (AF_UNIX) sockets, which are limited to 108 characters
// in length, so ZONENAME_MAX is limited by that.

// Extended Regular expression (see regex(7)) which matches all valid zone
// names.

// Where the zones support infrastructure places temporary files.

// The path to the door used by clients to communicate with zoneadmd.

// zone_flags
// Threads that read or write the following flag must hold zone_lock.

// The following threads are set when the zone is created and never changed.
// Threads that test for these flags don't have to hold zone_lock.

// zone_create flags

// zone network properties

type Zone_net_data_t = Zone_net_data /* zone.h:362:3 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1991-1998 by Sun Microsystems, Inc.
// All rights reserved.

// t_lock.h:	Prototypes for disp_locks, plus include files
//		that describe the interfaces to kernel synch.
//		objects.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2016 Joyent, Inc.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright (c) 1982, 1986, 1993 Regents of the University of California.
// All rights reserved.  The Berkeley software License Agreement
// specifies the terms and conditions for redistribution.

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2020 OmniOS Community Edition (OmniOSce) Association.

// Copyright (c) 2013, 2016 by Delphix. All rights reserved.

type Disp_lock_t = uint8 /* machlock.h:59:16 */

// The definitions of the symbolic interrupt levels:
//
//   CLOCK_LEVEL =>  The level at which one must be to block the clock.
//
//   LOCK_LEVEL  =>  The highest level at which one may block (and thus the
//                   highest level at which one may acquire adaptive locks)
//                   Also the highest level at which one may be preempted.
//
//   DISP_LEVEL  =>  The level at which one must be to perform dispatcher
//                   operations.
//
// The constraints on the platform:
//
//  - CLOCK_LEVEL must be less than or equal to LOCK_LEVEL
//  - LOCK_LEVEL must be less than DISP_LEVEL
//  - DISP_LEVEL should be as close to LOCK_LEVEL as possible
//
// Note that LOCK_LEVEL and CLOCK_LEVEL have historically always been equal;
// changing this relationship is probably possible but not advised.
//

// The following mask is for the cpu_intr_actv bits corresponding to
// high-level PILs. It should equal:
// ((((1 << PIL_MAX + 1) - 1) >> LOCK_LEVEL + 1) << LOCK_LEVEL + 1)

// The semaphore code depends on being able to represent a lock plus
// owner in a single 32-bit word.  (Mutexes used to have a similar
// dependency, but no longer.)  Thus the owner must contain at most
// 24 significant bits.  At present only threads and semaphores
// must be aware of this vile constraint.  Different ISAs may handle this
// differently depending on their capabilities (e.g. compare-and-swap)
// and limitations (e.g. constraints on alignment and/or KERNELBASE).

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2014 Nexenta Systems, Inc.  All rights reserved.
// Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1991, 2010, Oracle and/or its affiliates. All rights reserved.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// Public interface to mutual exclusion locks.  See mutex(9F) for details.
//
// The basic mutex type is MUTEX_ADAPTIVE, which is expected to be used
// in almost all of the kernel.  MUTEX_SPIN provides interrupt blocking
// and must be used in interrupt handlers above LOCK_LEVEL.  The iblock
// cookie argument to mutex_init() encodes the interrupt level to block.
// The iblock cookie must be NULL for adaptive locks.
//
// MUTEX_DEFAULT is the type usually specified (except in drivers) to
// mutex_init().  It is identical to MUTEX_ADAPTIVE.
//
// MUTEX_DRIVER is always used by drivers.  mutex_init() converts this to
// either MUTEX_ADAPTIVE or MUTEX_SPIN depending on the iblock cookie.
//
// Mutex statistics can be gathered on the fly, without rebooting or
// recompiling the kernel, via the lockstat driver (lockstat(4D)).
type Kmutex_type_t = uint32 /* mutex.h:61:3 */

type Mutex = struct{ F_opaque [1]uintptr } /* mutex.h:63:9 */

type Kmutex_t = Mutex /* mutex.h:69:3 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Copyright (c) 2013, Joyent, Inc.  All rights reserved.

// Public interface to readers/writer locks.  See rwlock(9F) for details.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

type Krw_type_t = uint32 /* rwlock.h:48:3 */

type Krw_t = uint32 /* rwlock.h:54:3 */

type X_krwlock = struct{ F_opaque [1]uintptr } /* rwlock.h:56:9 */

type Krwlock_t = X_krwlock /* rwlock.h:58:3 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1993-1998 by Sun Microsystems, Inc.
// All rights reserved.

// Public interface to semaphores.  See semaphore(9F) for details.

type Ksema_type_t = uint32 /* semaphore.h:47:3 */

type X_ksema = struct{ F_opaque [2]uintptr } /* semaphore.h:49:9 */

type Ksema_t = X_ksema /* semaphore.h:51:3 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Copyright (c) 2012 by Delphix. All rights reserved.

// condvar.h:
//
// definitions for thread synchronization primitives: condition variables
// This is the public part of the interface to condition variables. The
// private (implementation-specific) part is in <arch>/sys/condvar_impl.h.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright (c) 1982, 1986, 1993 Regents of the University of California.
// All rights reserved.  The Berkeley software License Agreement
// specifies the terms and conditions for redistribution.

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2020 OmniOS Community Edition (OmniOSce) Association.

// Copyright (c) 2013, 2016 by Delphix. All rights reserved.

// Condtion variables.

type X_kcondvar = struct{ F_opaque uint16 } /* condvar.h:59:9 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Copyright (c) 2012 by Delphix. All rights reserved.

// condvar.h:
//
// definitions for thread synchronization primitives: condition variables
// This is the public part of the interface to condition variables. The
// private (implementation-specific) part is in <arch>/sys/condvar_impl.h.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright (c) 1982, 1986, 1993 Regents of the University of California.
// All rights reserved.  The Berkeley software License Agreement
// specifies the terms and conditions for redistribution.

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2020 OmniOS Community Edition (OmniOSce) Association.

// Copyright (c) 2013, 2016 by Delphix. All rights reserved.

// Condtion variables.

type Kcondvar_t = X_kcondvar /* condvar.h:61:3 */

type Kcv_type_t = uint32 /* condvar.h:66:3 */

// Mutual exclusion locks described in common/sys/mutex.h.
//
// Semaphores described in common/sys/semaphore.h.
//
// Readers/Writer locks described in common/sys/rwlock.h.
//
// Condition variables described in common/sys/condvar.h

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Portions of this source code were derived from Berkeley 4.3 BSD
// under license from the Regents of the University of California.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
// Copyright 2020 Joyent, Inc.
// Copyright (c) 2011, 2017 by Delphix. All rights reserved.
// Copyright 2017 RackTop Systems.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1991-1998 by Sun Microsystems, Inc.
// All rights reserved.

// t_lock.h:	Prototypes for disp_locks, plus include files
//		that describe the interfaces to kernel synch.
//		objects.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Alternate rwlock that is interruptible and can be released by a thread
// other than the one that acquired the lock.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1991, Sun Microsystems, Inc.

// DKI/DDI MT synchronization primitives.

// The presence of this file is specified by the DKI/DDI.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1991-1998 by Sun Microsystems, Inc.
// All rights reserved.

// t_lock.h:	Prototypes for disp_locks, plus include files
//		that describe the interfaces to kernel synch.
//		objects.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Copyright (c) 2013, Joyent, Inc.  All rights reserved.

type Rwstlock = struct {
	Frwst_count  int64
	Frwst_rcv    Kcondvar_t
	Frwst_wcv    Kcondvar_t
	F__ccgo_pad1 [4]byte
	Frwst_lock   Kmutex_t
} /* rwstlock.h:43:9 */

// Mutual exclusion locks described in common/sys/mutex.h.
//
// Semaphores described in common/sys/semaphore.h.
//
// Readers/Writer locks described in common/sys/rwlock.h.
//
// Condition variables described in common/sys/condvar.h

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Portions of this source code were derived from Berkeley 4.3 BSD
// under license from the Regents of the University of California.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.
// Copyright 2020 Joyent, Inc.
// Copyright (c) 2011, 2017 by Delphix. All rights reserved.
// Copyright 2017 RackTop Systems.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1991-1998 by Sun Microsystems, Inc.
// All rights reserved.

// t_lock.h:	Prototypes for disp_locks, plus include files
//		that describe the interfaces to kernel synch.
//		objects.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Alternate rwlock that is interruptible and can be released by a thread
// other than the one that acquired the lock.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1991, Sun Microsystems, Inc.

// DKI/DDI MT synchronization primitives.

// The presence of this file is specified by the DKI/DDI.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright (c) 1991-1998 by Sun Microsystems, Inc.
// All rights reserved.

// t_lock.h:	Prototypes for disp_locks, plus include files
//		that describe the interfaces to kernel synch.
//		objects.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Copyright (c) 2013, Joyent, Inc.  All rights reserved.

type Rwstlock_t = Rwstlock /* rwstlock.h:48:3 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Implementation-private.  This header should not be included
// directly by an application.  The application should instead
// include <time.h> which includes this header conditionally
// depending on which feature test macros are defined. By default,
// this header is included by <time.h>.  X/Open and POSIX
// standards requirements result in this header being included
// by <time.h> only under a restricted set of conditions.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Portions of this source code were derived from Berkeley 4.3 BSD
// under license from the Regents of the University of California.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright (c) 2015, Joyent, Inc.  All rights reserved.

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// I/O parameter information.  A uio structure describes the I/O which
// is to be performed by an operation.  Typically the data movement will
// be performed by a routine such as uiomove(), which updates the uio
// structure to reflect what was done.

type Iovec = struct {
	Fiov_base uintptr
	Fiov_len  uint64
} /* uio.h:68:9 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Implementation-private.  This header should not be included
// directly by an application.  The application should instead
// include <time.h> which includes this header conditionally
// depending on which feature test macros are defined. By default,
// this header is included by <time.h>.  X/Open and POSIX
// standards requirements result in this header being included
// by <time.h> only under a restricted set of conditions.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Portions of this source code were derived from Berkeley 4.3 BSD
// under license from the Regents of the University of California.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright (c) 2015, Joyent, Inc.  All rights reserved.

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// I/O parameter information.  A uio structure describes the I/O which
// is to be performed by an operation.  Typically the data movement will
// be performed by a routine such as uiomove(), which updates the uio
// structure to reflect what was done.

type Iovec_t = Iovec /* uio.h:75:3 */

// Segment flag values.
type Uio_seg_t = uint32 /* uio.h:93:70 */

type Uio = struct {
	Fuio_iov     uintptr
	Fuio_iovcnt  int32
	F__ccgo_pad1 [4]byte
	F_uio_offset Lloff_t
	Fuio_segflg  uint32
	Fuio_fmode   uint16
	Fuio_extflg  uint16
	F_uio_limit  Lloff_t
	Fuio_resid   int64
} /* uio.h:95:9 */

type Uio_t = Uio /* uio.h:104:3 */

// Extended uio_t uioa_t used for asynchronous uio.
//
// Note: UIOA_IOV_MAX is defined and used as it is in "fs/vncalls.c"
//	 as there isn't a formal definition of IOV_MAX for the kernel.

type Uioa_page_s = struct {
	Fuioa_pfncnt int32
	F__ccgo_pad1 [4]byte
	Fuioa_ppp    uintptr
	Fuioa_base   uintptr
	Fuioa_len    uint64
} /* uio.h:114:9 */

// Extended uio_t uioa_t used for asynchronous uio.
//
// Note: UIOA_IOV_MAX is defined and used as it is in "fs/vncalls.c"
//	 as there isn't a formal definition of IOV_MAX for the kernel.

type Uioa_page_t = Uioa_page_s /* uio.h:119:3 */

type Uioa_s = struct {
	Fuio_iov     uintptr
	Fuio_iovcnt  int32
	F__ccgo_pad1 [4]byte
	F_uio_offset Lloff_t
	Fuio_segflg  uint32
	Fuio_fmode   uint16
	Fuio_extflg  uint16
	F_uio_limit  Lloff_t
	Fuio_resid   int64
	Fuioa_state  uint32
	F__ccgo_pad2 [4]byte
	Fuioa_mbytes int64
	Fuioa_lcur   uintptr
	Fuioa_lppp   uintptr
	Fuioa_hwst   [4]uintptr
	Fuioa_locked [16]Uioa_page_t
} /* uio.h:121:9 */

type Uioa_t = Uioa_s /* uio.h:139:3 */

// uio extensions
//
// PSARC 2009/478: Copy Reduction Interfaces
type Xuio_type_t = uint32 /* uio.h:150:3 */

type Xuio = struct {
	Fxu_uio      Uio_t
	Fxu_type     uint32
	F__ccgo_pad1 [4]byte
	Fxu_ext      struct {
		Fxu_aio struct {
			Fxu_a_state  uint32
			F__ccgo_pad1 [4]byte
			Fxu_a_mbytes int64
			Fxu_a_lcur   uintptr
			Fxu_a_lppp   uintptr
			Fxu_a_hwst   [4]uintptr
			Fxu_a_locked [16]Uioa_page_t
		}
	}
} /* uio.h:152:9 */

type Xuio_t = Xuio /* uio.h:189:3 */

// I/O direction.
type Uio_rw_t = uint32 /* uio.h:220:45 */

// uio_extflg: extended flags
//
// NOTE: This flag will be used in uiomove to determine if non-temporal
// access, ie, access bypassing caches, should be used.  Filesystems that
// don't initialize this field could experience suboptimal performance due to
// the random data the field contains.
//
// NOTE: This flag is also used by uioasync callers to pass an extended
// uio_t (uioa_t), to uioasync enabled consumers. Unlike above all
// consumers of a uioa_t require the uio_extflg to be initialized.

// Global uioasync capability shadow state.
type Uioasync_s = struct {
	Fenabled     uint32
	F__ccgo_pad1 [4]byte
	Fmincnt      uint64
} /* uio.h:243:9 */

// uio_extflg: extended flags
//
// NOTE: This flag will be used in uiomove to determine if non-temporal
// access, ie, access bypassing caches, should be used.  Filesystems that
// don't initialize this field could experience suboptimal performance due to
// the random data the field contains.
//
// NOTE: This flag is also used by uioasync callers to pass an extended
// uio_t (uioa_t), to uioasync enabled consumers. Unlike above all
// consumers of a uioa_t require the uio_extflg to be initialized.

// Global uioasync capability shadow state.
type Uioasync_t = Uioasync_s /* uio.h:246:3 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2014 Garrrett D'Amore <garrett@damore.org>
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
// Copyright 2017 Joyent, Inc.  All rights reserved.

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// University Copyright- Copyright (c) 1982, 1986, 1988
// The Regents of the University of California
// All Rights Reserved
//
// University Acknowledgment- Portions of this document are derived from
// software developed by the University of California, Berkeley, and its
// contributors.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright (c) 1982, 1986, 1993 Regents of the University of California.
// All rights reserved.  The Berkeley software License Agreement
// specifies the terms and conditions for redistribution.

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2020 OmniOS Community Edition (OmniOSce) Association.

// Copyright (c) 2013, 2016 by Delphix. All rights reserved.

// Process priority specifications

// Resource limits

type Rlim_t = uint64 /* resource.h:84:23 */

type Rlimit = struct {
	Frlim_cur uint64
	Frlim_max uint64
} /* resource.h:133:1 */

// transitional large file interface versions

type Rlim64_t = uint64 /* resource.h:141:22 */

type Rlimit64 = struct {
	Frlim_cur uint64
	Frlim_max uint64
} /* resource.h:147:1 */

// Although the saved rlimits were initially introduced by the large file API,
// they are now available for all resource limits on the 64-bit kernel and for
// cpu time and file size limits on the 32-bit kernel.

type Rusage = struct {
	Fru_utime struct {
		Ftv_sec  int64
		Ftv_usec int64
	}
	Fru_stime struct {
		Ftv_sec  int64
		Ftv_usec int64
	}
	Fru_maxrss   int64
	Fru_ixrss    int64
	Fru_idrss    int64
	Fru_isrss    int64
	Fru_minflt   int64
	Fru_majflt   int64
	Fru_nswap    int64
	Fru_inblock  int64
	Fru_oublock  int64
	Fru_msgsnd   int64
	Fru_msgrcv   int64
	Fru_nsignals int64
	Fru_nvcsw    int64
	Fru_nivcsw   int64
} /* resource.h:172:1 */

// Capabilities for capability segment op.
type Segcapability_t = uint32 /* seg_enum.h:82:3 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2015 Nexenta Systems, Inc.  All rights reserved.

// Definition of general kernel statistics structures and /dev/kstat ioctls

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright (c) 1982, 1986, 1993 Regents of the University of California.
// All rights reserved.  The Berkeley software License Agreement
// specifies the terms and conditions for redistribution.

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2020 OmniOS Community Edition (OmniOSce) Association.

// Copyright (c) 2013, 2016 by Delphix. All rights reserved.

type Kid_t = int32 /* kstat.h:42:13 */ // unique kstat id

// Kernel statistics driver (/dev/kstat) ioctls

// /dev/kstat ioctl usage (kd denotes /dev/kstat descriptor):
//
//	kcid = ioctl(kd, KSTAT_IOC_CHAIN_ID, NULL);
//	kcid = ioctl(kd, KSTAT_IOC_READ, kstat_t *);
//	kcid = ioctl(kd, KSTAT_IOC_WRITE, kstat_t *);

// The generic kstat header

type Kstat = struct {
	Fks_crtime    int64
	Fks_next      uintptr
	Fks_kid       int32
	Fks_module    [31]int8
	Fks_resv      uint8
	Fks_instance  int32
	Fks_name      [31]int8
	Fks_type      uint8
	Fks_class     [31]int8
	Fks_flags     uint8
	Fks_data      uintptr
	Fks_ndata     uint32
	F__ccgo_pad1  [4]byte
	Fks_data_size uint64
	Fks_snaptime  int64
	Fks_update    uintptr
	Fks_private   uintptr
	Fks_snapshot  uintptr
	Fks_lock      uintptr
} /* kstat.h:68:9 */

// unique kstat id

// Kernel statistics driver (/dev/kstat) ioctls

// /dev/kstat ioctl usage (kd denotes /dev/kstat descriptor):
//
//	kcid = ioctl(kd, KSTAT_IOC_CHAIN_ID, NULL);
//	kcid = ioctl(kd, KSTAT_IOC_READ, kstat_t *);
//	kcid = ioctl(kd, KSTAT_IOC_WRITE, kstat_t *);

// The generic kstat header

type Kstat_t = Kstat /* kstat.h:93:3 */

// kstat structure and locking strategy
//
// Each kstat consists of a header section (a kstat_t) and a data section.
// The system maintains a set of kstats, protected by kstat_chain_lock.
// kstat_chain_lock protects all additions to/deletions from this set,
// as well as all changes to kstat headers.  kstat data sections are
// *optionally* protected by the per-kstat ks_lock.  If ks_lock is non-NULL,
// kstat clients (e.g. /dev/kstat) will acquire this lock for all of their
// operations on that kstat.  It is up to the kstat provider to decide whether
// guaranteeing consistent data to kstat clients is sufficiently important
// to justify the locking cost.  Note, however, that most statistic updates
// already occur under one of the provider's mutexes, so if the provider sets
// ks_lock to point to that mutex, then kstat data locking is free.
//
// NOTE: variable-size kstats MUST employ kstat data locking, to prevent
// data-size races with kstat clients.
//
// NOTE: ks_lock is really of type (kmutex_t *); it is declared as (void *)
// in the kstat header so that users don't have to be exposed to all of the
// kernel's lock-related data structures.

// kstat time
//
// All times associated with kstats (e.g. creation time, snapshot time,
// kstat_timer_t and kstat_io_t timestamps, etc.) are 64-bit nanosecond values,
// as returned by gethrtime().  The accuracy of these timestamps is machine
// dependent, but the precision (units) is the same across all platforms.

// kstat identity (KID)
//
// Each kstat is assigned a unique KID (kstat ID) when it is added to the
// global kstat chain.  The KID is used as a cookie by /dev/kstat to
// request information about the corresponding kstat.  There is also
// an identity associated with the entire kstat chain, kstat_chain_id,
// which is bumped each time a kstat is added or deleted.  /dev/kstat uses
// the chain ID to detect changes in the kstat chain (e.g., a new disk
// coming online) between ioctl()s.

// kstat module, kstat instance
//
// ks_module and ks_instance contain the name and instance of the module
// that created the kstat.  In cases where there can only be one instance,
// ks_instance is 0.  The kernel proper (/kernel/unix) uses "unix" as its
// module name.

// kstat name
//
// ks_name gives a meaningful name to a kstat.  The full kstat namespace
// is module.instance.name, so the name only need be unique within a
// module.  kstat_create() will fail if you try to create a kstat with
// an already-used (ks_module, ks_instance, ks_name) triplet.  Spaces are
// allowed in kstat names, but strongly discouraged, since they hinder
// awk-style processing at user level.

// kstat type
//
// The kstat mechanism provides several flavors of kstat data, defined
// below.  The "raw" kstat type is just treated as an array of bytes; you
// can use this to export any kind of data you want.
//
// Some kstat types allow multiple data structures per kstat, e.g.
// KSTAT_TYPE_NAMED; others do not.  This is part of the spec for each
// kstat data type.
//
// User-level tools should *not* rely on the #define KSTAT_NUM_TYPES.  To
// get this information, read out the standard system kstat "kstat_types".

// ks_ndata >= 1
// ks_ndata >= 1
// ks_ndata == 1
// ks_ndata == 1
// ks_ndata >= 1

// kstat class
//
// Each kstat can be characterized as belonging to some broad class
// of statistics, e.g. disk, tape, net, vm, streams, etc.  This field
// can be used as a filter to extract related kstats.  The following
// values are currently in use: disk, tape, net, controller, vm, kvm,
// hat, streams, kstat, and misc.  (The kstat class encompasses things
// like kstat_types.)

// kstat flags
//
// Any of the following flags may be passed to kstat_create().  They are
// all zero by default.
//
//	KSTAT_FLAG_VIRTUAL:
//
//		Tells kstat_create() not to allocate memory for the
//		kstat data section; instead, you will set the ks_data
//		field to point to the data you wish to export.  This
//		provides a convenient way to export existing data
//		structures.
//
//	KSTAT_FLAG_VAR_SIZE:
//
//		The size of the kstat you are creating will vary over time.
//		For example, you may want to use the kstat mechanism to
//		export a linked list.  NOTE: The kstat framework does not
//		manage the data section, so all variable-size kstats must be
//		virtual kstats.  Moreover, variable-size kstats MUST employ
//		kstat data locking to prevent data-size races with kstat
//		clients.  See the section on "kstat snapshot" for details.
//
//	KSTAT_FLAG_WRITABLE:
//
//		Makes the kstat's data section writable by root.
//		The ks_snapshot routine (see below) does not need to check for
//		this; permission checking is handled in the kstat driver.
//
//	KSTAT_FLAG_PERSISTENT:
//
//		Indicates that this kstat is to be persistent over time.
//		For persistent kstats, kstat_delete() simply marks the
//		kstat as dormant; a subsequent kstat_create() reactivates
//		the kstat.  This feature is provided so that statistics
//		are not lost across driver close/open (e.g., raw disk I/O
//		on a disk with no mounted partitions.)
//		NOTE: Persistent kstats cannot be virtual, since ks_data
//		points to garbage as soon as the driver goes away.
//
// The following flags are maintained by the kstat framework:
//
//	KSTAT_FLAG_DORMANT:
//
//		For persistent kstats, indicates that the kstat is in the
//		dormant state (e.g., the corresponding device is closed).
//
//	KSTAT_FLAG_INVALID:
//
//		This flag is set when a kstat is in a transitional state,
//		e.g. between kstat_create() and kstat_install().
//		kstat clients must not attempt to access the kstat's data
//		if this flag is set.
//
//	KSTAT_FLAG_LONGSTRINGS:
//
//		Indicates that this kstat contains long strings (which
//		are stored outside of the kstat data section). When copied
//		out to user space the string data will be held in the data
//		section provided by the user.

// Dynamic update support
//
// The kstat mechanism allows for an optional ks_update function to update
// kstat data.  This is useful for drivers where the underlying device
// keeps cheap hardware stats, but extraction is expensive.  Instead of
// constantly keeping the kstat data section up to date, you can supply a
// ks_update function which updates the kstat's data section on demand.
// To take advantage of this feature, simply set the ks_update field before
// calling kstat_install().
//
// The ks_update function, if supplied, must have the following structure:
//
//	int
//	foo_kstat_update(kstat_t *ksp, int rw)
//	{
//		if (rw == KSTAT_WRITE) {
//			... update the native stats from ksp->ks_data;
//				return EACCES if you don't support this
//		} else {
//			... update ksp->ks_data from the native stats
//		}
//	}
//
// The ks_update return codes are: 0 for success, EACCES if you don't allow
// KSTAT_WRITE, and EIO for any other type of error.
//
// In general, the ks_update function may need to refer to provider-private
// data; for example, it may need a pointer to the provider's raw statistics.
// The ks_private field is available for this purpose.  Its use is entirely
// at the provider's discretion.
//
// All variable-size kstats MUST supply a ks_update routine, which computes
// and sets ks_data_size (and ks_ndata if that is meaningful), since these
// are needed to perform kstat snapshots (see below).
//
// No kstat locking should be done inside the ks_update routine.  The caller
// will already be holding the kstat's ks_lock (to ensure consistent data).

// Kstat snapshot
//
// In order to get a consistent view of a kstat's data, clients must obey
// the kstat's locking strategy.  However, these clients may need to perform
// operations on the data which could cause a fault (e.g. copyout()), or
// operations which are simply expensive.  Doing so could cause deadlock
// (e.g. if you're holding a disk's kstat lock which is ultimately required
// to resolve a copyout() fault), performance degradation (since the providers'
// activity is serialized at the kstat lock), device timing problems, etc.
//
// To avoid these problems, kstat data is provided via snapshots.  Taking
// a snapshot is a simple process: allocate a wired-down kernel buffer,
// acquire the kstat's data lock, copy the data into the buffer ("take the
// snapshot"), and release the lock.  This ensures that the kstat's data lock
// will be held as briefly as possible, and that no faults will occur while
// the lock is held.
//
// Normally, the snapshot is taken by default_kstat_snapshot(), which
// timestamps the data (sets ks_snaptime), copies it, and does a little
// massaging to deal with incomplete transactions on i/o kstats.  However,
// this routine only works for kstats with contiguous data (the typical case).
// If you create a kstat whose data is, say, a linked list, you must provide
// your own ks_snapshot routine.  The routine you supply must have the
// following prototype (replace "foo" with something appropriate):
//
//	int foo_kstat_snapshot(kstat_t *ksp, void *buf, int rw);
//
// The minimal snapshot routine -- one which copies contiguous data that
// doesn't need any massaging -- would be this:
//
//	ksp->ks_snaptime = gethrtime();
//	if (rw == KSTAT_WRITE)
//		bcopy(buf, ksp->ks_data, ksp->ks_data_size);
//	else
//		bcopy(ksp->ks_data, buf, ksp->ks_data_size);
//	return (0);
//
// A more illuminating example is taking a snapshot of a linked list:
//
//	ksp->ks_snaptime = gethrtime();
//	if (rw == KSTAT_WRITE)
//		return (EACCES);		... See below ...
//	for (foo = first_foo; foo; foo = foo->next) {
//		bcopy((char *) foo, (char *) buf, sizeof (struct foo));
//		buf = ((struct foo *) buf) + 1;
//	}
//	return (0);
//
// In the example above, we have decided that we don't want to allow
// KSTAT_WRITE access, so we return EACCES if this is attempted.
//
// The key points are:
//
//	(1) ks_snaptime must be set (via gethrtime()) to timestamp the data.
//	(2) Data gets copied from the kstat to the buffer on KSTAT_READ,
//		and from the buffer to the kstat on KSTAT_WRITE.
//	(3) ks_snapshot return values are: 0 for success, EACCES if you
//		don't allow KSTAT_WRITE, and EIO for any other type of error.
//
// Named kstats (see section on "Named statistics" below) containing long
// strings (KSTAT_DATA_STRING) need special handling.  The kstat driver
// assumes that all strings are copied into the buffer after the array of
// named kstats, and the pointers (KSTAT_NAMED_STR_PTR()) are updated to point
// into the copy within the buffer. The default snapshot routine does this,
// but overriding routines should contain at least the following:
//
// if (rw == KSTAT_READ) {
// 	kstat_named_t *knp = buf;
// 	char *end = knp + ksp->ks_ndata;
// 	uint_t i;
//
// 	... Do the regular copy ...
// 	bcopy(ksp->ks_data, buf, sizeof (kstat_named_t) * ksp->ks_ndata);
//
// 	for (i = 0; i < ksp->ks_ndata; i++, knp++) {
//		if (knp[i].data_type == KSTAT_DATA_STRING &&
//		    KSTAT_NAMED_STR_PTR(knp) != NULL) {
//			bcopy(KSTAT_NAMED_STR_PTR(knp), end,
//			    KSTAT_NAMED_STR_BUFLEN(knp));
//			KSTAT_NAMED_STR_PTR(knp) = end;
//			end += KSTAT_NAMED_STR_BUFLEN(knp);
//		}
//	}

// Named statistics.
//
// List of arbitrary name=value statistics.

type Kstat_named = struct {
	Fname      [31]int8
	Fdata_type uint8
	Fvalue     struct {
		F__ccgo_pad1 [0]uint64
		Fc           [16]int8
	}
} /* kstat.h:451:9 */

// kstat structure and locking strategy
//
// Each kstat consists of a header section (a kstat_t) and a data section.
// The system maintains a set of kstats, protected by kstat_chain_lock.
// kstat_chain_lock protects all additions to/deletions from this set,
// as well as all changes to kstat headers.  kstat data sections are
// *optionally* protected by the per-kstat ks_lock.  If ks_lock is non-NULL,
// kstat clients (e.g. /dev/kstat) will acquire this lock for all of their
// operations on that kstat.  It is up to the kstat provider to decide whether
// guaranteeing consistent data to kstat clients is sufficiently important
// to justify the locking cost.  Note, however, that most statistic updates
// already occur under one of the provider's mutexes, so if the provider sets
// ks_lock to point to that mutex, then kstat data locking is free.
//
// NOTE: variable-size kstats MUST employ kstat data locking, to prevent
// data-size races with kstat clients.
//
// NOTE: ks_lock is really of type (kmutex_t *); it is declared as (void *)
// in the kstat header so that users don't have to be exposed to all of the
// kernel's lock-related data structures.

// kstat time
//
// All times associated with kstats (e.g. creation time, snapshot time,
// kstat_timer_t and kstat_io_t timestamps, etc.) are 64-bit nanosecond values,
// as returned by gethrtime().  The accuracy of these timestamps is machine
// dependent, but the precision (units) is the same across all platforms.

// kstat identity (KID)
//
// Each kstat is assigned a unique KID (kstat ID) when it is added to the
// global kstat chain.  The KID is used as a cookie by /dev/kstat to
// request information about the corresponding kstat.  There is also
// an identity associated with the entire kstat chain, kstat_chain_id,
// which is bumped each time a kstat is added or deleted.  /dev/kstat uses
// the chain ID to detect changes in the kstat chain (e.g., a new disk
// coming online) between ioctl()s.

// kstat module, kstat instance
//
// ks_module and ks_instance contain the name and instance of the module
// that created the kstat.  In cases where there can only be one instance,
// ks_instance is 0.  The kernel proper (/kernel/unix) uses "unix" as its
// module name.

// kstat name
//
// ks_name gives a meaningful name to a kstat.  The full kstat namespace
// is module.instance.name, so the name only need be unique within a
// module.  kstat_create() will fail if you try to create a kstat with
// an already-used (ks_module, ks_instance, ks_name) triplet.  Spaces are
// allowed in kstat names, but strongly discouraged, since they hinder
// awk-style processing at user level.

// kstat type
//
// The kstat mechanism provides several flavors of kstat data, defined
// below.  The "raw" kstat type is just treated as an array of bytes; you
// can use this to export any kind of data you want.
//
// Some kstat types allow multiple data structures per kstat, e.g.
// KSTAT_TYPE_NAMED; others do not.  This is part of the spec for each
// kstat data type.
//
// User-level tools should *not* rely on the #define KSTAT_NUM_TYPES.  To
// get this information, read out the standard system kstat "kstat_types".

// ks_ndata >= 1
// ks_ndata >= 1
// ks_ndata == 1
// ks_ndata == 1
// ks_ndata >= 1

// kstat class
//
// Each kstat can be characterized as belonging to some broad class
// of statistics, e.g. disk, tape, net, vm, streams, etc.  This field
// can be used as a filter to extract related kstats.  The following
// values are currently in use: disk, tape, net, controller, vm, kvm,
// hat, streams, kstat, and misc.  (The kstat class encompasses things
// like kstat_types.)

// kstat flags
//
// Any of the following flags may be passed to kstat_create().  They are
// all zero by default.
//
//	KSTAT_FLAG_VIRTUAL:
//
//		Tells kstat_create() not to allocate memory for the
//		kstat data section; instead, you will set the ks_data
//		field to point to the data you wish to export.  This
//		provides a convenient way to export existing data
//		structures.
//
//	KSTAT_FLAG_VAR_SIZE:
//
//		The size of the kstat you are creating will vary over time.
//		For example, you may want to use the kstat mechanism to
//		export a linked list.  NOTE: The kstat framework does not
//		manage the data section, so all variable-size kstats must be
//		virtual kstats.  Moreover, variable-size kstats MUST employ
//		kstat data locking to prevent data-size races with kstat
//		clients.  See the section on "kstat snapshot" for details.
//
//	KSTAT_FLAG_WRITABLE:
//
//		Makes the kstat's data section writable by root.
//		The ks_snapshot routine (see below) does not need to check for
//		this; permission checking is handled in the kstat driver.
//
//	KSTAT_FLAG_PERSISTENT:
//
//		Indicates that this kstat is to be persistent over time.
//		For persistent kstats, kstat_delete() simply marks the
//		kstat as dormant; a subsequent kstat_create() reactivates
//		the kstat.  This feature is provided so that statistics
//		are not lost across driver close/open (e.g., raw disk I/O
//		on a disk with no mounted partitions.)
//		NOTE: Persistent kstats cannot be virtual, since ks_data
//		points to garbage as soon as the driver goes away.
//
// The following flags are maintained by the kstat framework:
//
//	KSTAT_FLAG_DORMANT:
//
//		For persistent kstats, indicates that the kstat is in the
//		dormant state (e.g., the corresponding device is closed).
//
//	KSTAT_FLAG_INVALID:
//
//		This flag is set when a kstat is in a transitional state,
//		e.g. between kstat_create() and kstat_install().
//		kstat clients must not attempt to access the kstat's data
//		if this flag is set.
//
//	KSTAT_FLAG_LONGSTRINGS:
//
//		Indicates that this kstat contains long strings (which
//		are stored outside of the kstat data section). When copied
//		out to user space the string data will be held in the data
//		section provided by the user.

// Dynamic update support
//
// The kstat mechanism allows for an optional ks_update function to update
// kstat data.  This is useful for drivers where the underlying device
// keeps cheap hardware stats, but extraction is expensive.  Instead of
// constantly keeping the kstat data section up to date, you can supply a
// ks_update function which updates the kstat's data section on demand.
// To take advantage of this feature, simply set the ks_update field before
// calling kstat_install().
//
// The ks_update function, if supplied, must have the following structure:
//
//	int
//	foo_kstat_update(kstat_t *ksp, int rw)
//	{
//		if (rw == KSTAT_WRITE) {
//			... update the native stats from ksp->ks_data;
//				return EACCES if you don't support this
//		} else {
//			... update ksp->ks_data from the native stats
//		}
//	}
//
// The ks_update return codes are: 0 for success, EACCES if you don't allow
// KSTAT_WRITE, and EIO for any other type of error.
//
// In general, the ks_update function may need to refer to provider-private
// data; for example, it may need a pointer to the provider's raw statistics.
// The ks_private field is available for this purpose.  Its use is entirely
// at the provider's discretion.
//
// All variable-size kstats MUST supply a ks_update routine, which computes
// and sets ks_data_size (and ks_ndata if that is meaningful), since these
// are needed to perform kstat snapshots (see below).
//
// No kstat locking should be done inside the ks_update routine.  The caller
// will already be holding the kstat's ks_lock (to ensure consistent data).

// Kstat snapshot
//
// In order to get a consistent view of a kstat's data, clients must obey
// the kstat's locking strategy.  However, these clients may need to perform
// operations on the data which could cause a fault (e.g. copyout()), or
// operations which are simply expensive.  Doing so could cause deadlock
// (e.g. if you're holding a disk's kstat lock which is ultimately required
// to resolve a copyout() fault), performance degradation (since the providers'
// activity is serialized at the kstat lock), device timing problems, etc.
//
// To avoid these problems, kstat data is provided via snapshots.  Taking
// a snapshot is a simple process: allocate a wired-down kernel buffer,
// acquire the kstat's data lock, copy the data into the buffer ("take the
// snapshot"), and release the lock.  This ensures that the kstat's data lock
// will be held as briefly as possible, and that no faults will occur while
// the lock is held.
//
// Normally, the snapshot is taken by default_kstat_snapshot(), which
// timestamps the data (sets ks_snaptime), copies it, and does a little
// massaging to deal with incomplete transactions on i/o kstats.  However,
// this routine only works for kstats with contiguous data (the typical case).
// If you create a kstat whose data is, say, a linked list, you must provide
// your own ks_snapshot routine.  The routine you supply must have the
// following prototype (replace "foo" with something appropriate):
//
//	int foo_kstat_snapshot(kstat_t *ksp, void *buf, int rw);
//
// The minimal snapshot routine -- one which copies contiguous data that
// doesn't need any massaging -- would be this:
//
//	ksp->ks_snaptime = gethrtime();
//	if (rw == KSTAT_WRITE)
//		bcopy(buf, ksp->ks_data, ksp->ks_data_size);
//	else
//		bcopy(ksp->ks_data, buf, ksp->ks_data_size);
//	return (0);
//
// A more illuminating example is taking a snapshot of a linked list:
//
//	ksp->ks_snaptime = gethrtime();
//	if (rw == KSTAT_WRITE)
//		return (EACCES);		... See below ...
//	for (foo = first_foo; foo; foo = foo->next) {
//		bcopy((char *) foo, (char *) buf, sizeof (struct foo));
//		buf = ((struct foo *) buf) + 1;
//	}
//	return (0);
//
// In the example above, we have decided that we don't want to allow
// KSTAT_WRITE access, so we return EACCES if this is attempted.
//
// The key points are:
//
//	(1) ks_snaptime must be set (via gethrtime()) to timestamp the data.
//	(2) Data gets copied from the kstat to the buffer on KSTAT_READ,
//		and from the buffer to the kstat on KSTAT_WRITE.
//	(3) ks_snapshot return values are: 0 for success, EACCES if you
//		don't allow KSTAT_WRITE, and EIO for any other type of error.
//
// Named kstats (see section on "Named statistics" below) containing long
// strings (KSTAT_DATA_STRING) need special handling.  The kstat driver
// assumes that all strings are copied into the buffer after the array of
// named kstats, and the pointers (KSTAT_NAMED_STR_PTR()) are updated to point
// into the copy within the buffer. The default snapshot routine does this,
// but overriding routines should contain at least the following:
//
// if (rw == KSTAT_READ) {
// 	kstat_named_t *knp = buf;
// 	char *end = knp + ksp->ks_ndata;
// 	uint_t i;
//
// 	... Do the regular copy ...
// 	bcopy(ksp->ks_data, buf, sizeof (kstat_named_t) * ksp->ks_ndata);
//
// 	for (i = 0; i < ksp->ks_ndata; i++, knp++) {
//		if (knp[i].data_type == KSTAT_DATA_STRING &&
//		    KSTAT_NAMED_STR_PTR(knp) != NULL) {
//			bcopy(KSTAT_NAMED_STR_PTR(knp), end,
//			    KSTAT_NAMED_STR_BUFLEN(knp));
//			KSTAT_NAMED_STR_PTR(knp) = end;
//			end += KSTAT_NAMED_STR_BUFLEN(knp);
//		}
//	}

// Named statistics.
//
// List of arbitrary name=value statistics.

type Kstat_named_t = Kstat_named /* kstat.h:492:3 */

// Statistics exporting named kstats with long strings (KSTAT_DATA_STRING)
// may not make the assumption that ks_data_size is equal to (ks_ndata * sizeof
// (kstat_named_t)).  ks_data_size in these cases is equal to the sum of the
// amount of space required to store the strings (ie, the sum of
// KSTAT_NAMED_STR_BUFLEN() for all KSTAT_DATA_STRING statistics) plus the
// space required to store the kstat_named_t's.
//
// The default update routine will update ks_data_size automatically for
// variable-length kstats containing long strings (using the default update
// routine only makes sense if the string is the only thing that is changing
// in size, and ks_ndata is constant).  Fixed-length kstats containing long
// strings must explicitly change ks_data_size (after creation but before
// initialization) to reflect the correct amount of space required for the
// long strings and the kstat_named_t's.

// These types are obsolete

// Retrieve the pointer of the string contained in the given named kstat.

// Retrieve the length of the buffer required to store the string in the given
// named kstat.

// Interrupt statistics.
//
// An interrupt is a hard interrupt (sourced from the hardware device
// itself), a soft interrupt (induced by the system via the use of
// some system interrupt source), a watchdog interrupt (induced by
// a periodic timer call), spurious (an interrupt entry point was
// entered but there was no interrupt condition to service),
// or multiple service (an interrupt condition was detected and
// serviced just prior to returning from any of the other types).
//
// Measurement of the spurious class of interrupts is useful for
// autovectored devices in order to pinpoint any interrupt latency
// problems in a particular system configuration.
//
// Devices that have more than one interrupt of the same
// type should use multiple structures.

type Kstat_intr = struct{ Fintrs [5]uint32 } /* kstat.h:578:9 */

// Statistics exporting named kstats with long strings (KSTAT_DATA_STRING)
// may not make the assumption that ks_data_size is equal to (ks_ndata * sizeof
// (kstat_named_t)).  ks_data_size in these cases is equal to the sum of the
// amount of space required to store the strings (ie, the sum of
// KSTAT_NAMED_STR_BUFLEN() for all KSTAT_DATA_STRING statistics) plus the
// space required to store the kstat_named_t's.
//
// The default update routine will update ks_data_size automatically for
// variable-length kstats containing long strings (using the default update
// routine only makes sense if the string is the only thing that is changing
// in size, and ks_ndata is constant).  Fixed-length kstats containing long
// strings must explicitly change ks_data_size (after creation but before
// initialization) to reflect the correct amount of space required for the
// long strings and the kstat_named_t's.

// These types are obsolete

// Retrieve the pointer of the string contained in the given named kstat.

// Retrieve the length of the buffer required to store the string in the given
// named kstat.

// Interrupt statistics.
//
// An interrupt is a hard interrupt (sourced from the hardware device
// itself), a soft interrupt (induced by the system via the use of
// some system interrupt source), a watchdog interrupt (induced by
// a periodic timer call), spurious (an interrupt entry point was
// entered but there was no interrupt condition to service),
// or multiple service (an interrupt condition was detected and
// serviced just prior to returning from any of the other types).
//
// Measurement of the spurious class of interrupts is useful for
// autovectored devices in order to pinpoint any interrupt latency
// problems in a particular system configuration.
//
// Devices that have more than one interrupt of the same
// type should use multiple structures.

type Kstat_intr_t = Kstat_intr /* kstat.h:580:3 */

// I/O statistics.

type Kstat_io = struct {
	Fnread       uint64
	Fnwritten    uint64
	Freads       uint32
	Fwrites      uint32
	Fwtime       int64
	Fwlentime    int64
	Fwlastupdate int64
	Frtime       int64
	Frlentime    int64
	Frlastupdate int64
	Fwcnt        uint32
	Frcnt        uint32
} /* kstat.h:588:9 */

// I/O statistics.

type Kstat_io_t = Kstat_io /* kstat.h:685:3 */

// Event timer statistics - cumulative elapsed time and number of events.
//
// Updates to these fields are performed implicitly by calls to
// kstat_timer_start() and kstat_timer_stop().

type Kstat_timer = struct {
	Fname         [31]int8
	Fresv         uint8
	Fnum_events   uint64
	Felapsed_time int64
	Fmin_time     int64
	Fmax_time     int64
	Fstart_time   int64
	Fstop_time    int64
} /* kstat.h:696:9 */

// Event timer statistics - cumulative elapsed time and number of events.
//
// Updates to these fields are performed implicitly by calls to
// kstat_timer_start() and kstat_timer_stop().

type Kstat_timer_t = Kstat_timer /* kstat.h:705:3 */

// Client response to kmem move callback
type Kmem_cbrc_t = uint32 /* kmem.h:98:3 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2003 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

type List_node = struct {
	Flist_next uintptr
	Flist_prev uintptr
} /* list_impl.h:36:1 */

type List = struct {
	Flist_size   uint64
	Flist_offset uint64
	Flist_head   struct {
		Flist_next uintptr
		Flist_prev uintptr
	}
} /* list_impl.h:41:1 */

type List_node_t = List_node /* list.h:35:26 */
type List_t = List           /* list.h:36:21 */

// Statistics for all vnode operations.
// All operations record number of ops (since boot/mount/zero'ed).
// Certain I/O operations (read, write, readdir) also record number
// of bytes transferred.
// This appears in two places in the system: one is embedded in each
// vfs_t.  There is also an array of vopstats_t structures allocated
// on a per-fstype basis.

type Vopstats = struct {
	Fnopen         Kstat_named_t
	Fnclose        Kstat_named_t
	Fnread         Kstat_named_t
	Fread_bytes    Kstat_named_t
	Fnwrite        Kstat_named_t
	Fwrite_bytes   Kstat_named_t
	Fnioctl        Kstat_named_t
	Fnsetfl        Kstat_named_t
	Fngetattr      Kstat_named_t
	Fnsetattr      Kstat_named_t
	Fnaccess       Kstat_named_t
	Fnlookup       Kstat_named_t
	Fncreate       Kstat_named_t
	Fnremove       Kstat_named_t
	Fnlink         Kstat_named_t
	Fnrename       Kstat_named_t
	Fnmkdir        Kstat_named_t
	Fnrmdir        Kstat_named_t
	Fnreaddir      Kstat_named_t
	Freaddir_bytes Kstat_named_t
	Fnsymlink      Kstat_named_t
	Fnreadlink     Kstat_named_t
	Fnfsync        Kstat_named_t
	Fninactive     Kstat_named_t
	Fnfid          Kstat_named_t
	Fnrwlock       Kstat_named_t
	Fnrwunlock     Kstat_named_t
	Fnseek         Kstat_named_t
	Fncmp          Kstat_named_t
	Fnfrlock       Kstat_named_t
	Fnspace        Kstat_named_t
	Fnrealvp       Kstat_named_t
	Fngetpage      Kstat_named_t
	Fnputpage      Kstat_named_t
	Fnmap          Kstat_named_t
	Fnaddmap       Kstat_named_t
	Fndelmap       Kstat_named_t
	Fnpoll         Kstat_named_t
	Fndump         Kstat_named_t
	Fnpathconf     Kstat_named_t
	Fnpageio       Kstat_named_t
	Fndumpctl      Kstat_named_t
	Fndispose      Kstat_named_t
	Fnsetsecattr   Kstat_named_t
	Fngetsecattr   Kstat_named_t
	Fnshrlock      Kstat_named_t
	Fnvnevent      Kstat_named_t
	Fnreqzcbuf     Kstat_named_t
	Fnretzcbuf     Kstat_named_t
} /* vnode.h:77:9 */

// Statistics for all vnode operations.
// All operations record number of ops (since boot/mount/zero'ed).
// Certain I/O operations (read, write, readdir) also record number
// of bytes transferred.
// This appears in two places in the system: one is embedded in each
// vfs_t.  There is also an array of vopstats_t structures allocated
// on a per-fstype basis.

type Vopstats_t = Vopstats /* vnode.h:127:3 */

// The vnode is the focus of all file activity in UNIX.
// A vnode is allocated for each active file, each current
// directory, each mounted-on file, and the root.
//
// Each vnode is usually associated with a file-system-specific node (for
// UFS, this is the in-memory inode).  Generally, a vnode and an fs-node
// should be created and destroyed together as a pair.
//
// If a vnode is reused for a new file, it should be reinitialized by calling
// either vn_reinit() or vn_recycle().
//
// vn_reinit() resets the entire vnode as if it was returned by vn_alloc().
// The caller is responsible for setting up the entire vnode after calling
// vn_reinit().  This is important when using kmem caching where the vnode is
// allocated by a constructor, for instance.
//
// vn_recycle() is used when the file system keeps some state around in both
// the vnode and the associated FS-node.  In UFS, for example, the inode of
// a deleted file can be reused immediately.  The v_data, v_vfsp, v_op, etc.
// remains the same but certain fields related to the previous instance need
// to be reset.  In particular:
//	v_femhead
//	v_path
//	v_rdcnt, v_wrcnt
//	v_mmap_read, v_mmap_write

// vnode types.  VNON means no type.  These values are unrelated to
// values in on-disk inodes.
type Vtype_t = uint32 /* vnode.h:174:3 */

// VSD - Vnode Specific Data
// Used to associate additional private data with a vnode.
type Vsd_node = struct {
	Fvs_nodes    List_node_t
	Fvs_nkeys    uint32
	F__ccgo_pad1 [4]byte
	Fvs_value    uintptr
} /* vnode.h:180:1 */

// from fem.h

type Vnode = struct {
	Fv_lock           Kmutex_t
	Fv_flag           uint32
	Fv_count          uint32
	Fv_phantom_count  uint32
	F__ccgo_pad1      [4]byte
	Fv_data           uintptr
	Fv_vfsp           uintptr
	Fv_stream         uintptr
	Fv_type           uint32
	F__ccgo_pad2      [4]byte
	Fv_rdev           uint64
	Fv_vfsmountedhere uintptr
	Fv_op             uintptr
	Fv_pages          uintptr
	Fv_filocks        uintptr
	Fv_shrlocks       uintptr
	Fv_nbllock        Krwlock_t
	Fv_cv             Kcondvar_t
	F__ccgo_pad3      [6]byte
	Fv_locality       uintptr
	Fv_femhead        uintptr
	Fv_path           uintptr
	Fv_path_stamp     int64
	Fv_rdcnt          uint32
	Fv_wrcnt          uint32
	Fv_mmap_read      uint64
	Fv_mmap_write     uint64
	Fv_mpssdata       uintptr
	Fv_fopdata        uintptr
	Fv_vsd_lock       Kmutex_t
	Fv_vsd            uintptr
	Fv_xattrdir       uintptr
	Fv_count_dnlc     uint32
	F__ccgo_pad4      [4]byte
} /* vnode.h:286:9 */

// from fem.h

type Vfs = struct {
	Fvfs_next         uintptr
	Fvfs_prev         uintptr
	Fvfs_op           uintptr
	Fvfs_vnodecovered uintptr
	Fvfs_flag         uint32
	Fvfs_bsize        uint32
	Fvfs_fstype       int32
	Fvfs_fsid         Fsid_t
	F__ccgo_pad1      [4]byte
	Fvfs_data         uintptr
	Fvfs_dev          uint64
	Fvfs_bcount       uint64
	Fvfs_list         uintptr
	Fvfs_hash         uintptr
	Fvfs_reflock      Ksema_t
	Fvfs_count        uint32
	F__ccgo_pad2      [4]byte
	Fvfs_mntopts      Mntopts_t
	Fvfs_resource     uintptr
	Fvfs_mntpt        uintptr
	Fvfs_mtime        int64
	Fvfs_implp        uintptr
	Fvfs_zone         uintptr
	Fvfs_zone_next    uintptr
	Fvfs_zone_prev    uintptr
	Fvfs_femhead      uintptr
	Fvfs_lofi_id      uint32
	F__ccgo_pad3      [4]byte
} /* vnode.h:286:9 */

// from fem.h

type Vnode_t = Vnode /* vnode.h:321:3 */

// Count of low-order 0 bits in a vnode *, based on size and alignment.

// vnode flags.

// The following two flags are used to lock the v_vfsmountedhere field

// Used to serialize VM operations on a vnode

// Tell vn_open() not to fail a directory open for writing but
// to go ahead and call VOP_OPEN() to let the filesystem check.

// Flag to let the VM system know that this file is most likely a binary
// or shared library since it has been mmap()ed EXEC at some time.

// Flag that indicates the VM should maintain the v_pages list with all modified
// pages on one end and unmodified pages at the other. This makes finding dirty
// pages to write back to disk much faster at the expense of taking a minor
// fault on the first store instruction which touches a writable page.

// The mdb memstat command assumes that IS_SWAPFSVP only uses the
// vnode's v_flag field.  If this changes, cache the additional
// fields in mdb; see vn_get in mdb/common/modules/genunix/memory.c

// Indication that VOP_LOOKUP operations on this vnode may yield results from a
// different VFS instance.  The main use of this is to suppress v_path
// calculation logic when filesystems such as procfs emit results which defy
// expectations about normal VFS behavior.

// Vnode attributes.  A bit-mask is supplied as part of the
// structure to indicate the attributes the caller wants to
// set (setattr) or extract (getattr).

// Note that va_nodeid and va_nblocks are 64bit data type.
// We support large files over NFSV3. With Solaris client and
// Server that generates 64bit ino's and sizes these fields
// will overflow if they are 32 bit sizes.

type Vattr = struct {
	Fva_mask     uint32
	Fva_type     uint32
	Fva_mode     uint32
	Fva_uid      uint32
	Fva_gid      uint32
	F__ccgo_pad1 [4]byte
	Fva_fsid     uint64
	Fva_nodeid   uint64
	Fva_nlink    uint32
	F__ccgo_pad2 [4]byte
	Fva_size     uint64
	Fva_atime    Timestruc_t
	Fva_mtime    Timestruc_t
	Fva_ctime    Timestruc_t
	Fva_rdev     uint64
	Fva_blksize  uint32
	F__ccgo_pad3 [4]byte
	Fva_nblocks  uint64
	Fva_seq      uint32
	F__ccgo_pad4 [4]byte
} /* vnode.h:434:9 */

// Count of low-order 0 bits in a vnode *, based on size and alignment.

// vnode flags.

// The following two flags are used to lock the v_vfsmountedhere field

// Used to serialize VM operations on a vnode

// Tell vn_open() not to fail a directory open for writing but
// to go ahead and call VOP_OPEN() to let the filesystem check.

// Flag to let the VM system know that this file is most likely a binary
// or shared library since it has been mmap()ed EXEC at some time.

// Flag that indicates the VM should maintain the v_pages list with all modified
// pages on one end and unmodified pages at the other. This makes finding dirty
// pages to write back to disk much faster at the expense of taking a minor
// fault on the first store instruction which touches a writable page.

// The mdb memstat command assumes that IS_SWAPFSVP only uses the
// vnode's v_flag field.  If this changes, cache the additional
// fields in mdb; see vn_get in mdb/common/modules/genunix/memory.c

// Indication that VOP_LOOKUP operations on this vnode may yield results from a
// different VFS instance.  The main use of this is to suppress v_path
// calculation logic when filesystems such as procfs emit results which defy
// expectations about normal VFS behavior.

// Vnode attributes.  A bit-mask is supplied as part of the
// structure to indicate the attributes the caller wants to
// set (setattr) or extract (getattr).

// Note that va_nodeid and va_nblocks are 64bit data type.
// We support large files over NFSV3. With Solaris client and
// Server that generates 64bit ino's and sizes these fields
// will overflow if they are 32 bit sizes.

type Vattr_t = Vattr /* vnode.h:451:3 */

// Structure of all optional attributes.
type Xoptattr = struct {
	Fxoa_createtime     Timestruc_t
	Fxoa_archive        uint8
	Fxoa_system         uint8
	Fxoa_readonly       uint8
	Fxoa_hidden         uint8
	Fxoa_nounlink       uint8
	Fxoa_immutable      uint8
	Fxoa_appendonly     uint8
	Fxoa_nodump         uint8
	Fxoa_opaque         uint8
	Fxoa_av_quarantined uint8
	Fxoa_av_modified    uint8
	Fxoa_av_scanstamp   [32]uint8
	Fxoa_reparse        uint8
	F__ccgo_pad1        [4]byte
	Fxoa_generation     uint64
	Fxoa_offline        uint8
	Fxoa_sparse         uint8
	Fxoa_projinherit    uint8
	F__ccgo_pad2        [5]byte
	Fxoa_projid         uint64
} /* vnode.h:458:9 */

// Structure of all optional attributes.
type Xoptattr_t = Xoptattr /* vnode.h:478:3 */

// The xvattr structure is really a variable length structure that
// is made up of:
// - The classic vattr_t (xva_vattr)
// - a 32 bit quantity (xva_mapsize) that specifies the size of the
//   attribute bitmaps in 32 bit words.
// - A pointer to the returned attribute bitmap (needed because the
//   previous element, the requested attribute bitmap) is variable lenth.
// - The requested attribute bitmap, which is an array of 32 bit words.
//   Callers use the XVA_SET_REQ() macro to set the bits corresponding to
//   the attributes that are being requested.
// - The returned attribute bitmap, which is an array of 32 bit words.
//   File systems that support optional attributes use the XVA_SET_RTN()
//   macro to set the bits corresponding to the attributes that are being
//   returned.
// - The xoptattr_t structure which contains the attribute values
//
// xva_mapsize determines how many words in the attribute bitmaps.
// Immediately following the attribute bitmaps is the xoptattr_t.
// xva_getxoptattr() is used to get the pointer to the xoptattr_t
// section.

// The xvattr structure is an extensible structure which permits optional
// attributes to be requested/returned.  File systems may or may not support
// optional attributes.  They do so at their own discretion but if they do
// support optional attributes, they must register the VFSFT_XVATTR feature
// so that the optional attributes can be set/retrived.
//
// The fields of the xvattr structure are:
//
// xva_vattr - The first element of an xvattr is a legacy vattr structure
// which includes the common attributes.  If AT_XVATTR is set in the va_mask
// then the entire structure is treated as an xvattr.  If AT_XVATTR is not
// set, then only the xva_vattr structure can be used.
//
// xva_magic - 0x78766174 (hex for "xvat"). Magic number for verification.
//
// xva_mapsize - Size of requested and returned attribute bitmaps.
//
// xva_rtnattrmapp - Pointer to xva_rtnattrmap[].  We need this since the
// size of the array before it, xva_reqattrmap[], could change which means
// the location of xva_rtnattrmap[] could change.  This will allow unbundled
// file systems to find the location of xva_rtnattrmap[] when the sizes change.
//
// xva_reqattrmap[] - Array of requested attributes.  Attributes are
// represented by a specific bit in a specific element of the attribute
// map array.  Callers set the bits corresponding to the attributes
// that the caller wants to get/set.
//
// xva_rtnattrmap[] - Array of attributes that the file system was able to
// process.  Not all file systems support all optional attributes.  This map
// informs the caller which attributes the underlying file system was able
// to set/get.  (Same structure as the requested attributes array in terms
// of each attribute  corresponding to specific bits and array elements.)
//
// xva_xoptattrs - Structure containing values of optional attributes.
// These values are only valid if the corresponding bits in xva_reqattrmap
// are set and the underlying file system supports those attributes.
type Xvattr = struct {
	Fxva_vattr       Vattr_t
	Fxva_magic       uint32
	Fxva_mapsize     uint32
	Fxva_rtnattrmapp uintptr
	Fxva_reqattrmap  [3]uint32
	Fxva_rtnattrmap  [3]uint32
	Fxva_xoptattrs   Xoptattr_t
} /* vnode.h:544:9 */

// The xvattr structure is really a variable length structure that
// is made up of:
// - The classic vattr_t (xva_vattr)
// - a 32 bit quantity (xva_mapsize) that specifies the size of the
//   attribute bitmaps in 32 bit words.
// - A pointer to the returned attribute bitmap (needed because the
//   previous element, the requested attribute bitmap) is variable lenth.
// - The requested attribute bitmap, which is an array of 32 bit words.
//   Callers use the XVA_SET_REQ() macro to set the bits corresponding to
//   the attributes that are being requested.
// - The returned attribute bitmap, which is an array of 32 bit words.
//   File systems that support optional attributes use the XVA_SET_RTN()
//   macro to set the bits corresponding to the attributes that are being
//   returned.
// - The xoptattr_t structure which contains the attribute values
//
// xva_mapsize determines how many words in the attribute bitmaps.
// Immediately following the attribute bitmaps is the xoptattr_t.
// xva_getxoptattr() is used to get the pointer to the xoptattr_t
// section.

// The xvattr structure is an extensible structure which permits optional
// attributes to be requested/returned.  File systems may or may not support
// optional attributes.  They do so at their own discretion but if they do
// support optional attributes, they must register the VFSFT_XVATTR feature
// so that the optional attributes can be set/retrived.
//
// The fields of the xvattr structure are:
//
// xva_vattr - The first element of an xvattr is a legacy vattr structure
// which includes the common attributes.  If AT_XVATTR is set in the va_mask
// then the entire structure is treated as an xvattr.  If AT_XVATTR is not
// set, then only the xva_vattr structure can be used.
//
// xva_magic - 0x78766174 (hex for "xvat"). Magic number for verification.
//
// xva_mapsize - Size of requested and returned attribute bitmaps.
//
// xva_rtnattrmapp - Pointer to xva_rtnattrmap[].  We need this since the
// size of the array before it, xva_reqattrmap[], could change which means
// the location of xva_rtnattrmap[] could change.  This will allow unbundled
// file systems to find the location of xva_rtnattrmap[] when the sizes change.
//
// xva_reqattrmap[] - Array of requested attributes.  Attributes are
// represented by a specific bit in a specific element of the attribute
// map array.  Callers set the bits corresponding to the attributes
// that the caller wants to get/set.
//
// xva_rtnattrmap[] - Array of attributes that the file system was able to
// process.  Not all file systems support all optional attributes.  This map
// informs the caller which attributes the underlying file system was able
// to set/get.  (Same structure as the requested attributes array in terms
// of each attribute  corresponding to specific bits and array elements.)
//
// xva_xoptattrs - Structure containing values of optional attributes.
// These values are only valid if the corresponding bits in xva_reqattrmap
// are set and the underlying file system supports those attributes.
type Xvattr_t = Xvattr /* vnode.h:552:3 */

type Vattr32_t = Vattr_t /* vnode.h:589:18 */ // reason for create

type Rm_t = uint32        /* vnode.h:800:18 */
type Symfollow_t = uint32 /* vnode.h:801:24 */
type Vcexcl_t = uint32    /* vnode.h:802:21 */
type Create_t = uint32    /* vnode.h:803:21 */

// Vnode Events - Used by VOP_VNEVENT
// The VE_PRE_RENAME_* events fire before the rename operation and are
// primarily used for specialized applications, such as NFSv4 delegation, which
// need to know about rename before it occurs.
type Vnevent_t = uint32 /* vnode.h:827:3 */

type V_mode_t = uint32 /* vnode.h:834:21 */

// Structure used on VOP_GETSECATTR and VOP_SETSECATTR operations

type Vsecattr = struct {
	Fvsa_mask      uint32
	Fvsa_aclcnt    int32
	Fvsa_aclentp   uintptr
	Fvsa_dfaclcnt  int32
	F__ccgo_pad1   [4]byte
	Fvsa_dfaclentp uintptr
	Fvsa_aclentsz  uint64
	Fvsa_aclflags  uint32
	F__ccgo_pad2   [4]byte
} /* vnode.h:843:9 */

// Structure used on VOP_GETSECATTR and VOP_SETSECATTR operations

type Vsecattr_t = Vsecattr /* vnode.h:851:3 */

// vsa_mask values

// Structure used by various vnode operations to determine
// the context (pid, host, identity) of a caller.
//
// The cc_caller_id is used to identify one or more callers who invoke
// operations, possibly on behalf of others.  For example, the NFS
// server could have it's own cc_caller_id which can be detected by
// vnode/vfs operations or (FEM) monitors on those operations.  New
// caller IDs are generated by fs_new_caller_id().
type Caller_context = struct {
	Fcc_pid       int32
	Fcc_sysid     int32
	Fcc_caller_id uint64
	Fcc_flags     uint64
} /* vnode.h:873:9 */

// vsa_mask values

// Structure used by various vnode operations to determine
// the context (pid, host, identity) of a caller.
//
// The cc_caller_id is used to identify one or more callers who invoke
// operations, possibly on behalf of others.  For example, the NFS
// server could have it's own cc_caller_id which can be detected by
// vnode/vfs operations or (FEM) monitors on those operations.  New
// caller IDs are generated by fs_new_caller_id().
type Caller_context_t = Caller_context /* vnode.h:878:3 */
type Fid = struct {
	Fun struct {
		Ffid_pad     int64
		F__ccgo_pad1 [64]byte
	}
} /* vnode.h:892:1 */

// Flags for VOP_LOOKUP
//
// Defined in file.h, but also possible, FIGNORECASE and FSEARCH
//

// Flags for VOP_READDIR

// Flags for VOP_RWLOCK/VOP_RWUNLOCK
// VOP_RWLOCK will return the flag that was actually set, or -1 if none.

// Flags for VOP_DUMPCTL

// Public vnode manipulation functions.

// Flags to VOP_SETATTR/VOP_GETATTR.
// Generally useful macros.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// Structure returned by statvfs(2).

type Statvfs = struct {
	Ff_bsize    uint64
	Ff_frsize   uint64
	Ff_blocks   uint64
	Ff_bfree    uint64
	Ff_bavail   uint64
	Ff_files    uint64
	Ff_ffree    uint64
	Ff_favail   uint64
	Ff_fsid     uint64
	Ff_basetype [16]int8
	Ff_flag     uint64
	Ff_namemax  uint64
	Ff_fstr     [32]int8
} /* statvfs.h:53:9 */

// Flags for VOP_LOOKUP
//
// Defined in file.h, but also possible, FIGNORECASE and FSEARCH
//

// Flags for VOP_READDIR

// Flags for VOP_RWLOCK/VOP_RWUNLOCK
// VOP_RWLOCK will return the flag that was actually set, or -1 if none.

// Flags for VOP_DUMPCTL

// Public vnode manipulation functions.

// Flags to VOP_SETATTR/VOP_GETATTR.
// Generally useful macros.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

//  DO NOT EDIT THIS FILE.
//
//     It has been auto-edited by fixincludes from:
//
// 	"/usr/include/sys/feature_tests.h"
//
//     This had to be done to correct non-standard usages in the
//     original, manufacturer supplied header file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END

// Copyright 2013 Garrett D'Amore <garrett@damore.org>
// Copyright 2016 Joyent, Inc.
// Copyright 2022 Oxide Computer Company
//
// Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// Structure returned by statvfs(2).

type Statvfs_t = Statvfs /* statvfs.h:71:3 */

// transitional large file interface version
type Statvfs64 = struct {
	Ff_bsize    uint64
	Ff_frsize   uint64
	Ff_blocks   uint64
	Ff_bfree    uint64
	Ff_bavail   uint64
	Ff_files    uint64
	Ff_ffree    uint64
	Ff_favail   uint64
	Ff_fsid     uint64
	Ff_basetype [16]int8
	Ff_flag     uint64
	Ff_namemax  uint64
	Ff_fstr     [32]int8
} /* statvfs.h:99:9 */

// transitional large file interface version
type Statvfs64_t = Statvfs64 /* statvfs.h:117:3 */

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// Copyright (c) 2014 by Delphix. All rights reserved.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License, Version 1.0 only
// (the "License").  You may not use this file except in compliance
// with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.

// This is a private header file.  Applications should not directly include
// this file.

// CDDL HEADER START
//
// The contents of this file are subject to the terms of the
// Common Development and Distribution License (the "License").
// You may not use this file except in compliance with the License.
//
// You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
// or http://www.opensolaris.org/os/licensing.
// See the License for the specific language governing permissions
// and limitations under the License.
//
// When distributing Covered Code, include this CDDL HEADER in each
// file and include the License file at usr/src/OPENSOLARIS.LICENSE.
// If applicable, add the following below this CDDL HEADER, with the
// fields enclosed by brackets "[]" replaced with your own identifying
// information: Portions Copyright [yyyy] [name of copyright owner]
//
// CDDL HEADER END
//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2021 Oxide Computer Company

// generic AVL tree implementation for kernel use
//
// There are 5 pieces of information stored for each node in an AVL tree
//
// 	pointer to less than child
// 	pointer to greater than child
// 	a pointer to the parent of this node
//	an indication  [0/1]  of which child I am of my parent
// 	a "balance" (-1, 0, +1)  indicating which child tree is taller
//
// Since they only need 3 bits, the last two fields are packed into the
// bottom bits of the parent pointer on 64 bit machines to save on space.

// for 64 bit machines, avl_pcb contains parent pointer, balance and child_index
// values packed in the following manner:
//
// |63                                  3|        2        |1          0 |
// |-------------------------------------|-----------------|-------------|
// |      avl_parent hi order bits       | avl_child_index | avl_balance |
// |                                     |                 |     + 1     |
// |-------------------------------------|-----------------|-------------|
type Avl_node = struct {
	Favl_child [2]uintptr
	Favl_pcb   uint64
} /* avl_impl.h:88:1 */

// macros to extract/set fields in avl_pcb
//
// pointer to the parent of the current node is the high order bits

// index of this node in its parent's avl_child[]: bit #2

// balance indication for a node, lowest 2 bits. A valid balance is
// -1, 0, or +1, and is encoded by adding 1 to the value to get the
// unsigned values of 0, 1, 2.

// switch between a node and data pointer for a given tree
// the value of "o" is tree->avl_offset

// macros used to create/access an avl_index_t

// The tree structure. The fields avl_root, avl_compar, and avl_offset come
// first since they are needed for avl_find().  We want them to fit into
// a single 64 byte cache line to make avl_find() as fast as possible.
type Avl_tree = struct {
	Favl_root     uintptr
	Favl_compar   uintptr
	Favl_offset   uint64
	Favl_numnodes uint64
	Favl_size     uint64
} /* avl_impl.h:144:1 */

// This is a generic implementation of AVL trees for use in the illumos. The
// interfaces provide an efficient way of implementing an ordered set of data
// structures.
//
// AVL trees provide an alternative to using an ordered linked list. Using AVL
// trees will usually be faster, however they requires more storage. An ordered
// linked list in general requires 2 pointers in each data structure. The
// AVL tree implementation uses 3 pointers. The following chart gives the
// approximate performance of operations with the different approaches:
//
//	Operation	 Link List	AVL tree
//	---------	 --------	--------
//	lookup		   O(n)		O(log(n))
//
//	insert 1 node	 constant	O(log(n))
//
//	delete 1 node	 constant	between constant and O(log(n))
//
//	delete all nodes   O(n)		O(n)
//
//	visit the next
//	or prev node	 constant	between constant and O(log(n))
//
//
// The data structure nodes are anchored at an "avl_tree_t" (the equivalent
// of a list header) and the individual nodes will have a field of
// type "avl_node_t" (corresponding to list pointers).
//
// The type "avl_index_t" is used to indicate a position in the list for
// certain calls.
//
// The usage scenario is generally:
//
// 1. Create the list/tree with: avl_create()
//
// followed by any mixture of:
//
// 2a. Insert nodes with: avl_add(), or avl_find() and avl_insert()
//
// 2b. Visited elements with:
//	 avl_first() - returns the lowest valued node
//	 avl_last() - returns the highest valued node
//	 AVL_NEXT() - given a node go to next higher one
//	 AVL_PREV() - given a node go to previous lower one
//
// 2c.  Find the node with the closest value either less than or greater
//	than a given value with avl_nearest().
//
// 2d. Remove individual nodes from the list/tree with avl_remove().
//
// and finally when the list is being destroyed
//
// 3. Use avl_destroy_nodes() to quickly process/free up any remaining nodes.
//    Note that once you use avl_destroy_nodes(), you can no longer
//    use any routine except avl_destroy_nodes() and avl_destoy().
//
// 4. Use avl_destroy() to destroy the AVL tree itself.
//
// Any locking for multiple thread access is up to the user to provide, just
// as is needed for any linked list implementation.

// AVL comparator helpers

// Type used for the root of the AVL tree.
type Avl_tree_t = Avl_tree /* avl.h:114:25 */

// The data nodes in the AVL tree must have a field of this type.
type Avl_node_t = Avl_node /* avl.h:119:25 */

// An opaque type used to locate a position in the tree where a node
// would be inserted.
type Avl_index_t = uint64 /* avl.h:125:19 */

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright (c) 1982, 1986, 1993 Regents of the University of California.
// All rights reserved.  The Berkeley software License Agreement
// specifies the terms and conditions for redistribution.

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2020 OmniOS Community Edition (OmniOSce) Association.

// Copyright (c) 2013, 2016 by Delphix. All rights reserved.

// Data associated with mounted file systems.

// Operations vector.  This is used internal to the kernel; file systems
// supply their list of operations via vfs_setfsops().

type Vfsops = struct {
	Fvfs_mount     uintptr
	Fvfs_unmount   uintptr
	Fvfs_root      uintptr
	Fvfs_statvfs   uintptr
	Fvfs_sync      uintptr
	Fvfs_vget      uintptr
	Fvfs_mountroot uintptr
	Fvfs_freevfs   uintptr
	Fvfs_vnstate   uintptr
} /* vnode.h:286:9 */

//	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T
//	  All Rights Reserved

// Copyright (c) 1982, 1986, 1993 Regents of the University of California.
// All rights reserved.  The Berkeley software License Agreement
// specifies the terms and conditions for redistribution.

// Copyright 2014 Garrett D'Amore <garrett@damore.org>
//
// Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
// Use is subject to license terms.
//
// Copyright 2013 Nexenta Systems, Inc.  All rights reserved.
// Copyright 2016 Joyent, Inc.
// Copyright 2020 OmniOS Community Edition (OmniOSce) Association.

// Copyright (c) 2013, 2016 by Delphix. All rights reserved.

// Data associated with mounted file systems.

// Operations vector.  This is used internal to the kernel; file systems
// supply their list of operations via vfs_setfsops().

type Vfsops_t = Vfsops /* vfs.h:63:23 */

// File system identifier. Should be unique (at least per machine).
type Fsid_t = struct{ Fval [2]int32 } /* vfs.h:70:3 */

// File identifier.  Should be unique per filesystem on a single
// machine.  This is typically called by a stateless file server
// in order to generate "file handles".
//
// Many underlying file systems cast a struct fid into other
// file system dependent structures which may require 4 byte alignment.
// Because a fid starts with a short it may not be 4 byte aligned, the
// fid_pad will force the alignment.

type Fid_t = Fid /* vfs.h:93:3 */

type Fid32_t = Fid_t /* vfs.h:111:15 */

// Structure defining a mount option for a filesystem.
// option names are found in mntent.h
type Mntopt = struct {
	Fmo_name     uintptr
	Fmo_cancel   uintptr
	Fmo_arg      uintptr
	Fmo_flags    int32
	F__ccgo_pad1 [4]byte
	Fmo_data     uintptr
} /* vnode.h:286:9 */

// Structure defining a mount option for a filesystem.
// option names are found in mntent.h
type Mntopt_t = Mntopt /* vfs.h:127:3 */

// Flags that apply to mount options

// Structure holding mount option strings for the mounted file system.
type Mntopts = struct {
	Fmo_count    uint32
	F__ccgo_pad1 [4]byte
	Fmo_list     uintptr
} /* vnode.h:286:9 */

// Flags that apply to mount options

// Structure holding mount option strings for the mounted file system.
type Mntopts_t = Mntopts /* vfs.h:152:3 */

// The kstat structures associated with the vopstats are kept in an
// AVL tree.  This is to avoid the case where a file system does not
// use a unique fsid_t for each vfs (e.g., namefs).  In order to do
// this, we need a structure that the AVL tree can use that also
// references the kstat.
// Note that the vks_fsid is generated from the value reported by
// VFS_STATVFS().
type Vskstat_anchor = struct {
	Fvsk_node Avl_node_t
	Fvsk_ksp  uintptr
	Fvsk_fsid uint64
} /* vfs.h:163:9 */

// The kstat structures associated with the vopstats are kept in an
// AVL tree.  This is to avoid the case where a file system does not
// use a unique fsid_t for each vfs (e.g., namefs).  In order to do
// this, we need a structure that the AVL tree can use that also
// references the kstat.
// Note that the vks_fsid is generated from the value reported by
// VFS_STATVFS().
type Vsk_anchor_t = Vskstat_anchor /* vfs.h:167:3 */ // from fem.h

type Vfs_t = Vfs /* vfs.h:234:3 */

// VFS flags.

// VFS features are implemented as bits set in the vfs_t.
// The vfs_feature_t typedef is a 64-bit number that will translate
// into an element in an array of bitmaps and a bit in that element.
// Developers must not depend on the implementation of this and
// need to use vfs_has_feature()/vfs_set_feature() routines.
type Vfs_feature_t = uint64 /* vfs.h:270:18 */

// Support loaning /returning cache buffer
// Argument structure for mount(2).
//
// Flags are defined in <sys/mount.h>.
//
// Note that if the MS_SYSSPACE bit is set in flags, the pointer fields in
// this structure are to be interpreted as kernel addresses.  File systems
// should be prepared for this possibility.
type Mounta = struct {
	Fspec        uintptr
	Fdir         uintptr
	Fflags       int32
	F__ccgo_pad1 [4]byte
	Ffstype      uintptr
	Fdataptr     uintptr
	Fdatalen     int32
	F__ccgo_pad2 [4]byte
	Foptptr      uintptr
	Foptlen      int32
	F__ccgo_pad3 [4]byte
} /* vfs.h:292:1 */

type Whymountroot_t = uint32 /* vfs.h:307:27 */
type Vntrans_t = uint32      /* vfs.h:318:22 */

// Filesystem type switch table.

type Vfssw = struct {
	Fvsw_name     uintptr
	Fvsw_init     uintptr
	Fvsw_flag     int32
	F__ccgo_pad1  [4]byte
	Fvsw_optproto Mntopts_t
	Fvsw_count    uint32
	F__ccgo_pad2  [4]byte
	Fvsw_lock     Kmutex_t
	Fvsw_vfsops   Vfsops_t
} /* vfs.h:376:9 */

// Filesystem type switch table.

type Vfssw_t = Vfssw /* vfs.h:385:3 */

// Filesystem type definition record.  All file systems must export a record
// of this type through their modlfs structure.  N.B., changing the version
// number requires a change in sys/modctl.h.

type Vfsdef_v51 = struct {
	Fdef_version int32
	F__ccgo_pad1 [4]byte
	Fname        uintptr
	Finit        uintptr
	Fflags       int32
	F__ccgo_pad2 [4]byte
	Foptproto    uintptr
} /* vfs.h:393:9 */

// Filesystem type definition record.  All file systems must export a record
// of this type through their modlfs structure.  N.B., changing the version
// number requires a change in sys/modctl.h.

type Vfsdef_v5 = Vfsdef_v51 /* vfs.h:399:3 */

type Vfsdef_t = Vfsdef_v51 /* vfs.h:401:26 */

// flags for vfssw and vfsdef

// A flag for vfs_setpath().

// VFS_SYNC flags.

var _ int8 /* gen.c:2:13: */
